{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/test_suite.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\n\nimport * as ensure from \"../util/ensure.js\";\nimport { Clock } from \"../infrastructure/clock.js\";\nimport { TestCaseResult, TestMark, TestMarkValue, TestResult, TestStatus, TestSuiteResult } from \"./test_result.js\";\nimport path from \"node:path\";\n\n// A simple but full-featured test runner. It allows me to get away from Mocha's idiosyncracies and have\n// more control over test execution, while also shielding me from dependency churn.\n\n\nconst DEFAULT_TIMEOUT_IN_MS = 2000;\n\nexport interface TestConfig {\n\t[name: string]: unknown,\n}\n\nexport interface TestOptions {\n\ttimeout?: Milliseconds,\n\tconfig?: TestConfig,\n\tnotifyFn?: NotifyFn,\n\tclock?: Clock,\n}\n\nexport interface DescribeOptions {\n\ttimeout?: number,\n}\n\nexport interface ItOptions {\n\ttimeout?: number,\n}\n\nexport type NotifyFn = (testResult: TestCaseResult) => void;\n\ninterface Describe {\n\t(\n\t\toptionalName?: string | DescribeOptions | DescribeFn,\n\t\toptionalOptions?: DescribeOptions | DescribeFn,\n\t\tdescribeFn?: DescribeFn\n\t): TestSuite,\n\tskip: (\n\t\toptionalName?: string | DescribeOptions | DescribeFn,\n\t\toptionalOptions?: DescribeOptions | DescribeFn,\n\t\tdescrbeFn?: DescribeFn\n\t) => TestSuite,\n\tonly: (\n\t\toptionalName?: string | DescribeOptions | DescribeFn,\n\t\toptionalOptions?: DescribeOptions | DescribeFn,\n\t\tdescribeFn?: DescribeFn\n\t) => TestSuite,\n}\ntype DescribeFn = () => void;\n\ninterface It {\n\t(name: string, optionalOptions?: ItOptions | ItFn, itFn?: ItFn): void;\n\tskip: (name: string, optionalOptions?: ItOptions | ItFn, itFn?: ItFn) => void,\n\tonly: (name: string, optionalOptions?: ItOptions | ItFn, itFn?: ItFn) => void,\n}\ntype ItFn = (testUtilities: TestParameters) => Promise<void> | void;\n\ntype BeforeAfter = (optionalOptions: ItOptions | ItFn, fnAsync?: ItFn) => void;\n\ntype BeforeAfterDefinition = { options: ItOptions, fnAsync: ItFn };\n\ninterface TestParameters {\n\tgetConfig: <T>(key: string) => T,\n}\n\ntype Milliseconds = number;\n\ninterface RecursiveRunOptions {\n\tname: string[];\n\tfilename?: string;\n\tclock: Clock,\n\tnotifyFn: NotifyFn,\n\ttimeout: Milliseconds,\n\tconfig: TestConfig,\n}\n\ninterface Runnable {\n\t_recursiveRunAsync: (\n\t\tparentMark: TestMarkValue,\n\t\tparentBeforeEachFns: BeforeAfterDefinition[],\n\t\tparentAfterEachFns: BeforeAfterDefinition[],\n\t\toptions: RecursiveRunOptions,\n\t) => Promise<TestResult> | TestResult;\n\t_isDotOnly: () => boolean,\n\t_isSkipped: (mark: TestMarkValue) => boolean,\n}\n\ninterface TestContext {\n\tdescribe: Describe,\n\tit: It,\n\tbeforeAll: BeforeAfter,\n\tafterAll: BeforeAfter,\n\tbeforeEach: BeforeAfter,\n\tafterEach: BeforeAfter,\n}\n\nconst testContext: TestContext[] = [];\n\n/**\n * A simple but full-featured test runner. It's notable for not using globals.\n */\nexport class TestSuite implements Runnable {\n\n\tprivate _name: string;\n\tprivate _mark: TestMarkValue;\n\tprivate _tests: Runnable[];\n\tprivate _hasDotOnlyChildren: boolean;\n\tprivate _allChildrenSkipped: boolean;\n\tprivate _beforeAllFns: BeforeAfterDefinition[];\n\tprivate _afterAllFns: BeforeAfterDefinition[];\n\tprivate _beforeEachFns: BeforeAfterDefinition[];\n\tprivate _afterEachFns: BeforeAfterDefinition[];\n\tprivate _timeout?: Milliseconds;\n\tprivate _filename?: string;\n\n\tstatic get DEFAULT_TIMEOUT_IN_MS() {\n\t\treturn DEFAULT_TIMEOUT_IN_MS;\n\t}\n\n\t/**\n\t * Convert a list of test modules into a test suite. Each module needs to export a test suite by using\n\t * {@link TestSuite.create}.\n\t * @param {string[]} moduleFilenames The filenames of the test modules.\n\t * @returns {TestSuite} The test suite.\n\t */\n\tstatic async fromModulesAsync(moduleFilenames: string[]): Promise<TestSuite> {\n\t\tensure.signature(arguments, [ Array ]);\n\n\t\tconst suites = await Promise.all(moduleFilenames.map(filename => loadModuleAsync(filename)));\n\t\treturn new TestSuite(\"\", TestMark.none, { tests: suites });\n\n\t\tasync function loadModuleAsync(filename: string): Promise<TestSuite> {\n\t\t\tconst errorName = `error when importing ${path.basename(filename)}`;\n\n\t\t\tif (!path.isAbsolute(filename)) {\n\t\t\t\treturn createFailure(errorName, `Test module filenames must use absolute paths: ${filename}`);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst { default: suite } = await import(filename);\n\t\t\t\tif (suite instanceof TestSuite) {\n\t\t\t\t\tsuite._setFilename(filename);\n\t\t\t\t\treturn suite;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn createFailure(errorName, `Test module doesn't export a test suite: ${filename}`, filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(err) {\n\t\t\t\tconst code = (err as { code: string })?.code;\n\t\t\t\tif (code === \"ERR_MODULE_NOT_FOUND\") {\n\t\t\t\t\treturn createFailure(errorName, `Test module not found: ${filename}`, filename);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn createFailure(errorName, err, filename);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction createFailure(name: string, error: unknown, filename?: string) {\n\t\t\treturn new TestSuite(\"\", TestMark.none, { tests: [ new FailureTestCase(name, error, filename) ] });\n\t\t}\n\t}\n\n\t/** @private */\n\tstatic _create(\n\t\tnameOrOptionsOrSuiteFn: string | DescribeOptions | DescribeFn | undefined,\n\t\toptionsOrSuiteFn: DescribeOptions | DescribeFn | undefined,\n\t\tpossibleSuiteFn: DescribeFn | undefined,\n\t\tmark: TestMarkValue,\n\t): TestSuite {\n\t\tconst DescribeOptionsType = { timeout: Number };\n\t\tensure.signature(arguments, [\n\t\t\t[ undefined, DescribeOptionsType, String, Function ],\n\t\t\t[ undefined, DescribeOptionsType, Function ],\n\t\t\t[ undefined, Function ],\n\t\t\tString\n\t\t]);\n\n\t\tconst { name, options, suiteFn } = decipherOverloadedParameters();\n\n\t\tif (suiteFn !== undefined) {\n\t\t\treturn this.#runDescribeFunction(suiteFn, name, mark, options.timeout);\n\t\t}\n\t\telse if (mark === TestMark.only) {\n\t\t\treturn new TestSuite(name, mark, {\n\t\t\t\ttests: [ new FailureTestCase(name, \"Test suite is marked '.only', but has no body\") ],\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn new TestSuite(name, TestMark.skip, { timeout: options.timeout });\n\t\t}\n\n\t\tfunction decipherOverloadedParameters() {\n\t\t\tlet name: string;\n\t\t\tlet options: DescribeOptions | undefined;\n\t\t\tlet suiteFn: DescribeFn | undefined;\n\n\t\t\tswitch (typeof nameOrOptionsOrSuiteFn) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tname = nameOrOptionsOrSuiteFn;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"object\":\n\t\t\t\t\toptions = nameOrOptionsOrSuiteFn;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tsuiteFn = nameOrOptionsOrSuiteFn;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"undefined\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tensure.unreachable(`Unknown typeof for nameOrOptionsOrSuiteFn: ${typeof nameOrOptionsOrSuiteFn}`);\n\t\t\t}\n\t\t\tswitch (typeof optionsOrSuiteFn) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\tensure.that(options === undefined, \"Received two options parameters\");\n\t\t\t\t\toptions = optionsOrSuiteFn;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tensure.that(suiteFn === undefined, \"Received two suite function parameters\");\n\t\t\t\t\tsuiteFn = optionsOrSuiteFn;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"undefined\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tensure.unreachable(`Unknown typeof for optionsOrSuiteFn: ${typeof optionsOrSuiteFn}`);\n\t\t\t}\n\t\t\tif (possibleSuiteFn !== undefined) {\n\t\t\t\tensure.that(suiteFn === undefined, \"Received two suite function parameters\");\n\t\t\t\tsuiteFn = possibleSuiteFn;\n\t\t\t}\n\n\t\t\tname ??= \"\";\n\t\t\toptions ??= {};\n\n\t\t\treturn { name, options, suiteFn };\n\t\t}\n\t}\n\n\tstatic #runDescribeFunction(\n\t\tdescribeFn: DescribeFn,\n\t\tname: string,\n\t\tmark: TestMarkValue,\n\t\ttimeout?: Milliseconds,\n\t): TestSuite {\n\t\tconst tests: Runnable[] = [];\n\t\tconst beforeAllFns: BeforeAfterDefinition[] = [];\n\t\tconst afterAllFns: BeforeAfterDefinition[] = [];\n\t\tconst beforeEachFns: BeforeAfterDefinition[] = [];\n\t\tconst afterEachFns: BeforeAfterDefinition[] = [];\n\n\t\tconst pushTest = <T extends Runnable>(test: T): T => {\n\t\t\ttests.push(test);\n\t\t\treturn test;\n\t\t};\n\n\t\tconst result: Describe = (optionalName, optionalOptions, fn) => this._create(optionalName, optionalOptions, fn, TestMark.none);\n\t\tresult.skip = (optionalName, optionalOptions, fn) => this._create(optionalName, optionalOptions, fn, TestMark.skip);\n\t\tresult.only = (optionalName, optionalOptions, fn) => this._create(optionalName, optionalOptions, fn, TestMark.only);\n\n\t\tconst describe: Describe = (optionalName, optionalOptions, fn) => pushTest(TestSuite._create(optionalName, optionalOptions, fn, TestMark.none));\n\t\tdescribe.skip = (optionalName, optionalOptions, fn) => pushTest(TestSuite._create(optionalName, optionalOptions, fn, TestMark.skip));\n\t\tdescribe.only = (optionalName, optionalOptions, fn) => pushTest(TestSuite._create(optionalName, optionalOptions, fn, TestMark.only));\n\n\t\tconst it: It = (name, optionalOptions, testCaseFn) => pushTest(new TestCase(name, optionalOptions, testCaseFn, TestMark.none));\n\t\tit.skip = (name, optionalOptions, testCaseFn) => pushTest(new TestCase(name, optionalOptions, testCaseFn, TestMark.skip));\n\t\tit.only = (name, optionalOptions, testCaseFn) => pushTest(new TestCase(name, optionalOptions, testCaseFn, TestMark.only));\n\n\t\ttestContext.push({\n\t\t\tdescribe,\n\t\t\tit,\n\t\t\tbeforeAll: defineBeforeAfterFn(beforeAllFns),\n\t\t\tafterAll: defineBeforeAfterFn(afterAllFns),\n\t\t\tbeforeEach: defineBeforeAfterFn(beforeEachFns),\n\t\t\tafterEach: defineBeforeAfterFn(afterEachFns),\n\t\t});\n\t\ttry {\n\t\t\tdescribeFn();\n\t\t}\n\t\tfinally {\n\t\t\ttestContext.pop();\n\t\t}\n\n\t\treturn new TestSuite(name, mark, { tests, beforeAllFns, afterAllFns, beforeEachFns, afterEachFns, timeout });\n\n\t\tfunction defineBeforeAfterFn(beforeAfterArray: BeforeAfterDefinition[]) {\n\t\t\treturn function (optionsOrFnAsync: ItOptions | ItFn, possibleFnAsync?: ItFn) {\n\t\t\t\tensure.signature(arguments, [\n\t\t\t\t\t[ { timeout: Number }, Function ],\n\t\t\t\t\t[ undefined, Function ],\n\t\t\t\t]);\n\n\t\t\t\tlet options: ItOptions;\n\t\t\t\tlet fnAsync: ItFn;\n\n\t\t\t\tif (possibleFnAsync === undefined) {\n\t\t\t\t\toptions = {};\n\t\t\t\t\tfnAsync = optionsOrFnAsync as ItFn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toptions = optionsOrFnAsync as ItOptions;\n\t\t\t\t\tfnAsync = possibleFnAsync;\n\t\t\t\t}\n\n\t\t\t\tbeforeAfterArray.push({ options, fnAsync });\n\t\t\t};\n\t\t}\n\t}\n\n\t/** Internal use only. (Use {@link TestSuite.create} or {@link TestSuite.fromModulesAsync} instead.) */\n\tconstructor(name: string, mark: TestMarkValue, {\n\t\ttests = [],\n\t\tbeforeAllFns = [],\n\t\tafterAllFns = [],\n\t\tbeforeEachFns = [],\n\t\tafterEachFns = [],\n\t\ttimeout,\n\t}: {\n\t\ttests?: Runnable[],\n\t\tbeforeAllFns?: BeforeAfterDefinition[],\n\t\tafterAllFns?: BeforeAfterDefinition[],\n\t\tbeforeEachFns?: BeforeAfterDefinition[],\n\t\tafterEachFns?: BeforeAfterDefinition[],\n\t\ttimeout?: Milliseconds,\n\t}) {\n\t\tthis._name = name;\n\t\tthis._mark = mark;\n\t\tthis._tests = tests;\n\t\tthis._hasDotOnlyChildren = this._tests.some(test => test._isDotOnly());\n\t\tthis._allChildrenSkipped = this._tests.every(test => test._isSkipped(this._mark));\n\t\tthis._beforeAllFns = beforeAllFns;\n\t\tthis._afterAllFns = afterAllFns;\n\t\tthis._beforeEachFns = beforeEachFns;\n\t\tthis._afterEachFns = afterEachFns;\n\t\tthis._timeout = timeout;\n\t}\n\n\t/**\n\t * Run the tests in this suite.\n\t * @param {number} [timeout] Default timeout in milliseconds.\n\t * @param {object} [config={}] Configuration data to provide to tests.\n\t * @param {(result: TestResult) => ()} [notifyFn] A function to call each time a test completes. The `result`\n\t *   parameter describes the result of the test—whether it passed, failed, etc.\n\t * @param {Clock} [clock] The clock to use. Meant for internal use.\n\t * @returns {Promise<TestSuiteResult>} The results of the test suite.\n\t */\n\tasync runAsync({\n\t\ttimeout = DEFAULT_TIMEOUT_IN_MS,\n\t\tconfig = {},\n\t\tnotifyFn = () => {},\n\t\tclock = Clock.create(),\n\t}: TestOptions = {}): Promise<TestSuiteResult> {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\ttimeout: [ undefined, Number ],\n\t\t\tconfig: [ undefined, Object ],\n\t\t\tnotifyFn: [ undefined, Function ],\n\t\t\tclock: [ undefined, Clock ],\n\t\t}]]);\n\n\t\treturn await this._recursiveRunAsync(TestMark.only, [], [], {\n\t\t\tclock,\n\t\t\tconfig,\n\t\t\tnotifyFn,\n\t\t\tname: [],\n\t\t\tfilename: this._filename,\n\t\t\ttimeout: this._timeout ?? timeout ?? DEFAULT_TIMEOUT_IN_MS,\n\t\t});\n\t}\n\n\t/** @private */\n\t_setFilename(filename: string) { this._filename = filename; }\n\n\t/** @private */\n\t_isDotOnly(): boolean {\n\t\treturn this._mark === TestMark.only || this._hasDotOnlyChildren;\n\t}\n\n\t/** @private */\n\t_isSkipped(): boolean {\n\t\treturn this._allChildrenSkipped;\n\t}\n\n\t/** @private */\n\tasync _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tparentBeforeEachFns: BeforeAfterDefinition[],\n\t\tparentAfterEachFns: BeforeAfterDefinition[],\n\t\toptions: RecursiveRunOptions,\n\t) {\n\t\tconst name = [ ...options.name ];\n\t\tif (this._name !== \"\") name.push(this._name);\n\t\tconst filename = this._filename ?? options.filename;\n\t\tconst timeout = this._timeout ?? options.timeout;\n\t\toptions = { ...options, name, filename, timeout };\n\n\t\tlet myMark = this._mark;\n\t\tif (myMark === TestMark.none) myMark = parentMark;\n\t\tif (myMark === TestMark.only && this._hasDotOnlyChildren) myMark = TestMark.skip;\n\n\t\tconst beforeEachFns = [ ...parentBeforeEachFns, ...this._beforeEachFns ];\n\t\tconst afterEachFns = [ ...this._afterEachFns, ...parentAfterEachFns ];\n\n\t\tif (!this._allChildrenSkipped) {\n\t\t\tconst beforeResult = await runBeforeOrAfterFnsAsync(\n\t\t\t\t[ ...options.name, \"beforeAll()\" ], this._beforeAllFns, TestMark.none, options,\n\t\t\t);\n\t\t\tif (!isSuccess(beforeResult)) return TestResult.suite(options.name, [ beforeResult ], options.filename, this._mark);\n\t\t}\n\n\t\tconst results = [];\n\t\tfor await (const test of this._tests) {\n\t\t\tresults.push(await test._recursiveRunAsync(myMark, beforeEachFns, afterEachFns, options));\n\t\t}\n\n\t\tif (!this._allChildrenSkipped) {\n\t\t\tconst afterResult = await runBeforeOrAfterFnsAsync(\n\t\t\t\t[ ...options.name, \"afterAll()\" ], this._afterAllFns, TestMark.none, options\n\t\t\t);\n\t\t\tif (!isSuccess(afterResult)) results.push(afterResult);\n\t\t}\n\n\t\treturn TestResult.suite(options.name, results, options.filename, this._mark);\n\t}\n\n}\n\n\nclass TestCase implements Runnable {\n\n\tprotected _name: string;\n\tprivate _timeout?: Milliseconds;\n\tprivate _testFn?: ItFn;\n\tprivate _mark: TestMarkValue;\n\n\tconstructor(\n\t\tname: string,\n\t\toptionsOrTestFn: TestOptions | ItFn | undefined,\n\t\tpossibleTestFn: ItFn | undefined,\n\t\tmark: TestMarkValue\n\t) {\n\t\tensure.signature(arguments, [\n\t\t\tString,\n\t\t\t[ undefined, { timeout: [ undefined, Number ]}, Function ],\n\t\t\t[ undefined, Function ],\n\t\t\tString\n\t\t]);\n\n\t\tthis._name = name;\n\n\t\tswitch (typeof optionsOrTestFn) {\n\t\t\tcase \"object\":\n\t\t\t\tthis._timeout = optionsOrTestFn.timeout;\n\t\t\t\tbreak;\n\t\t\tcase \"function\":\n\t\t\t\tthis._testFn = optionsOrTestFn;\n\t\t\t\tbreak;\n\t\t\tcase \"undefined\":\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tensure.unreachable(`Unknown typeof optionsOrTestFn: ${typeof optionsOrTestFn}`);\n\t\t}\n\t\tif (possibleTestFn !== undefined) {\n\t\t\tensure.that(this._testFn === undefined, \"Received two test function parameters\");\n\t\t\tthis._testFn = possibleTestFn;\n\t\t}\n\n\t\tthis._mark = mark;\n\t}\n\n\t/** @private */\n\t_isDotOnly(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this._mark === TestMark.only;\n\t}\n\n\t/** @private */\n\t_isSkipped(parentMark: TestMarkValue): boolean {\n\t\tconst inheritedMark = this._mark === TestMark.none ? parentMark : this._mark;\n\t\treturn inheritedMark === TestMark.skip;\n\t}\n\n\t/** @private */\n\tasync _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tbeforeEachFns: BeforeAfterDefinition[],\n\t\tafterEachFns: BeforeAfterDefinition[],\n\t\toptions: RecursiveRunOptions,\n\t): Promise<TestCaseResult> {\n\t\tconst name = [ ...options.name ];\n\t\tname.push(this._name !== \"\" ? this._name : \"(unnamed)\");\n\t\toptions = { ...options, name };\n\n\t\tlet result;\n\t\tif (this._testFn !== undefined) {\n\t\t\tif (!this._isSkipped(parentMark)) {\n\t\t\t\tresult = await runTestAsync(this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = TestResult.skip(name, options.filename, this._mark);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this._mark !== TestMark.only) {\n\t\t\t\tresult = TestResult.skip(name, options.filename, TestMark.skip);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = TestResult.fail(name, \"Test is marked '.only', but it has no body\", options.filename, this._mark);\n\t\t\t}\n\t\t}\n\n\t\toptions.notifyFn(result);\n\t\treturn result;\n\n\t\tasync function runTestAsync(self: TestCase): Promise<TestCaseResult> {\n\t\t\tconst beforeResult = await runBeforeOrAfterFnsAsync(options.name, beforeEachFns, self._mark, options);\n\t\t\tif (!isSuccess(beforeResult)) return beforeResult;\n\n\t\t\tconst itResult = await runTestFnAsync(options.name, self._testFn!, self._mark, self._timeout, options);\n\t\t\tconst afterResult = await runBeforeOrAfterFnsAsync(options.name, afterEachFns, self._mark, options);\n\n\t\t\tif (!isSuccess(itResult)) return itResult;\n\t\t\telse return afterResult;\n\t\t}\n\t}\n}\n\n\nclass FailureTestCase extends TestCase {\n\n\tprivate _filename?: string;\n\tprivate _error: unknown;\n\n\tconstructor(name: string, error: unknown, filename?: string) {\n\t\tsuper(name, undefined, undefined, TestMark.none);\n\n\t\tthis._filename = filename;\n\t\tthis._error = error;\n\t}\n\n\toverride async _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tbeforeEachFns: BeforeAfterDefinition[],\n\t\tafterEachFns: BeforeAfterDefinition[],\n\t\toptions: RecursiveRunOptions,\n\t): Promise<TestCaseResult> {\n\t\tconst result = TestResult.fail([ this._name ], this._error, this._filename);\n\t\toptions.notifyFn(result);\n\t\treturn await result;\n\t}\n\n}\n\n\nasync function runBeforeOrAfterFnsAsync(\n\tname: string[],\n\tbeforeAfterArray: BeforeAfterDefinition[],\n\tmark: TestMarkValue,\n\toptions: RecursiveRunOptions,\n): Promise<TestCaseResult> {\n\tfor await (const beforeAfter of beforeAfterArray) {\n\t\tconst result = await runTestFnAsync(name, beforeAfter.fnAsync, mark, beforeAfter.options.timeout, options);\n\t\tif (!isSuccess(result)) return result;\n\t}\n\treturn TestResult.pass(name, options.filename, mark);\n}\n\nasync function runTestFnAsync(\n\tname: string[],\n\tfn: ItFn,\n\tmark: TestMarkValue,\n\ttestTimeout: Milliseconds | undefined,\n\t{ clock, filename, timeout, config }: RecursiveRunOptions,\n): Promise<TestCaseResult> {\n\tconst getConfig = <T>(name: string) => {\n\t\tif (config[name] === undefined) throw new Error(`No test config found for name '${name}'`);\n\t\treturn config[name] as T;\n\t};\n\n\ttimeout = testTimeout ?? timeout;\n\n\treturn await clock.timeoutAsync(timeout, async () => {\n\t\ttry {\n\t\t\tawait fn({ getConfig });\n\t\t\treturn TestResult.pass(name, filename, mark);\n\t\t}\n\t\tcatch (err) {\n\t\t\treturn TestResult.fail(name, err, filename, mark);\n\t\t}\n\t}, async () => {\n\t\treturn await TestResult.timeout(name, timeout, filename, mark);\n\t});\n}\n\nfunction isSuccess(result: TestCaseResult) {\n\treturn result.status === TestStatus.pass || result.status === TestStatus.skip;\n}\n\n\nfunction startTest(\n\toptionalName: string | DescribeOptions | DescribeFn | undefined,\n\toptionalOptions: DescribeOptions | DescribeFn | undefined,\n\tfn: DescribeFn | undefined,\n\tmark: TestMarkValue,\n): TestSuite {\n\tensure.that(testContext.length === 0, \"test() is not re-entrant [don't run test() inside of test()]\");\n\n\ttry {\n\t\treturn TestSuite._create(optionalName, optionalOptions, fn, mark);\n\t}\n\tfinally {\n\t\tensure.that(testContext.length === 0, \"test() didn't clear its context; must be an error in ergotest\");\n\t}\n}\n\n/**\n * Creates a top-level test suite. In your test module, call this function and `export default` the result. Add `.skip`\n * to skip this test suite and `.only` to only run this test suite.\n * @param {string} [optionalName] The name of the test suite. You can skip this parameter and pass\n *   {@link optionalOptions} or {@link fn} instead.\n * @param {DescribeOptions} [optionalOptions] The test suite options. You can skip this parameter and pass {@link fn}\n *   instead.\n * @param {function} [fn] The body of the test suite. In the body, call {@link describe}, {@link it}, {@link\n *   beforeAll}, {@link afterAll}, {@link beforeEach}, and {@link afterEach} to define the tests in the suite. If\n *   undefined, this test suite will be skipped.\n * @returns {TestSuite} The test suite. You’ll typically `export default` the return value rather than using it\n *   directly.\n */\nexport function test(\n\toptionalName?: string | DescribeOptions | DescribeFn,\n\toptionalOptions?: DescribeOptions | DescribeFn,\n\tfn?: DescribeFn,\n): TestSuite {\n\treturn startTest(optionalName, optionalOptions, fn, TestMark.none);\n}\n\ntest.skip = function(\n\toptionalName?: string | DescribeOptions | DescribeFn,\n\toptionalOptions?: DescribeOptions | DescribeFn,\n\tfn?: DescribeFn,\n): TestSuite {\n\treturn startTest(optionalName, optionalOptions, fn, TestMark.skip);\n};\n\ntest.only = function(\n\toptionalName?: string | DescribeOptions | DescribeFn,\n\toptionalOptions?: DescribeOptions | DescribeFn,\n\tfn?: DescribeFn,\n): TestSuite {\n\treturn startTest(optionalName, optionalOptions, fn, TestMark.only);\n};\n\n/**\n * Adds a nested test suite to the current test suite. Must be run inside of a {@link test} or {@link describe}\n * function. Add `.skip` to skip this test suite and `.only` to only run this test suite.\n * @param {string} [optionalName] The name of the test suite. You can skip this parameter and pass\n *   {@link optionalOptions} or {@link fn} instead.\n * @param {DescribeOptions} [optionalOptions] The test suite options. You can skip this parameter and pass {@link fn}\n *   instead.\n * @param {function} [fn] The body of the test suite. In the body, call {@link describe}, {@link it}, {@link\n *   beforeAll}, {@link afterAll}, {@link beforeEach}, and {@link afterEach} to define the tests in the suite. If\n *   undefined, this test suite will be skipped.\n * @returns {TestSuite} The test suite. You’ll typically ignore the return value.\n */\nexport function describe(\n\toptionalName?: string | DescribeOptions | DescribeFn,\n\toptionalOptions?: DescribeOptions | DescribeFn,\n\tfn?: DescribeFn,\n) {\n\tcurrentContext(\"describe\").describe(optionalName, optionalOptions, fn);\n}\n\ndescribe.skip = function(\n\toptionalName?: string | DescribeOptions | DescribeFn,\n\toptionalOptions?: DescribeOptions | DescribeFn,\n\tfn?: DescribeFn,\n) {\n\tcurrentContext(\"describe\").describe.skip(optionalName, optionalOptions, fn);\n};\n\ndescribe.only = function(\n\toptionalName?: string | DescribeOptions | DescribeFn,\n\toptionalOptions?: DescribeOptions | DescribeFn,\n\tfn?: DescribeFn,\n) {\n\tcurrentContext(\"describe\").describe.only(optionalName, optionalOptions, fn);\n};\n\n/**\n * Adds a test to the current test suite. Must be run inside of a {@link test} or {@link describe} function. Add\n * `.skip` to skip this test and `.only` to only run this test.\n * @param {string} name The name of the test.\n * @param {ItOptions} [optionalOptions] The test options. You can skip this parameter and pass {@link fnAsync} instead.\n * @param {function} [fnAsync] The body of the test. May be synchronous or asynchronous. If undefined, this test will be\n *   skipped.\n */\nexport function it(name: string, optionalOptions?: ItOptions | ItFn, fnAsync?: ItFn) {\n\tcurrentContext(\"it\").it(name, optionalOptions, fnAsync);\n}\n\nit.skip = function it(name: string, optionalOptions?: ItOptions | ItFn, fnAsync?: ItFn) {\n\tcurrentContext(\"it\").it.skip(name, optionalOptions, fnAsync);\n};\n\nit.only = function it(name: string, optionalOptions?: ItOptions | ItFn, fnAsync?: ItFn) {\n\tcurrentContext(\"it\").it.only(name, optionalOptions, fnAsync);\n};\n\n/**\n * Adds a function to run before all the tests in the current test suite. Must be run inside of a {@link test} or\n * {@link describe} function.\n * @param {ItOptions} [optionalOptions] The before/after options. You can skip this parameter and pass @{link fnAsync}\n *   instead.\n * @param {function} fnAsync The function to run. May be synchronous or asynchronous.\n */\nexport function beforeAll(optionalOptions: ItOptions | ItFn, fnAsync?: ItFn) {\n\tcurrentContext(\"beforeAll\").beforeAll(optionalOptions, fnAsync);\n}\n\n/**\n * Adds a function to run after all the tests in the current test suite. Must be run inside of a {@link test} or\n * {@link describe} function.\n * @param {ItOptions} [optionalOptions] The before/after options. You can skip this parameter and pass @{link fnAsync}\n *   instead.\n * @param {function} [fnAsync] The function to run. May be synchronous or asynchronous.\n */\nexport function afterAll(optionalOptions: ItOptions | ItFn, fnAsync?: ItFn) {\n\tcurrentContext(\"afterAll\").afterAll(optionalOptions, fnAsync);\n}\n\n/**\n * Adds a function to run bfeore each of the tests in the current test suite. Must be run inside of a {@link test} or\n * {@link describe} function.\n * @param {ItOptions} [optionalOptions] The before/after options. You can skip this parameter and pass @{link fnAsync}\n *   instead.\n * @param {function} [fnAsync] The function to run. May be synchronous or asynchronous.\n */\nexport function beforeEach(optionalOptions: ItOptions | ItFn, fnAsync?: ItFn) {\n\tcurrentContext(\"beforeEach\").beforeEach(optionalOptions, fnAsync);\n}\n\n/**\n * Adds a function to run after each of the tests in the current test suite. Must be run inside of a {@link test} or\n * {@link describe} function.\n * @param {ItOptions} [optionalOptions] The before/after options. You can skip this parameter and pass @{link fnAsync}\n *   instead.\n * @param {function} [fnAsync] The function to run. May be synchronous or asynchronous.\n */\nexport function afterEach(optionalOptions: ItOptions | ItFn, fnAsync?: ItFn) {\n\tcurrentContext(\"afterEach\").afterEach(optionalOptions, fnAsync);\n}\n\nfunction currentContext(functionName: string) {\n\tensure.that(testContext.length > 0, `${functionName}() must be run inside test()`);\n\n\treturn testContext[testContext.length - 1];\n}"],"names":["ensure","Clock","TestMark","TestResult","TestStatus","path","DEFAULT_TIMEOUT_IN_MS","testContext","TestSuite","_name","_mark","_tests","_hasDotOnlyChildren","_allChildrenSkipped","_beforeAllFns","_afterAllFns","_beforeEachFns","_afterEachFns","_timeout","_filename","fromModulesAsync","moduleFilenames","signature","arguments","Array","suites","Promise","all","map","filename","loadModuleAsync","none","tests","errorName","basename","isAbsolute","createFailure","default","suite","_setFilename","err","code","name","error","FailureTestCase","_create","nameOrOptionsOrSuiteFn","optionsOrSuiteFn","possibleSuiteFn","mark","DescribeOptionsType","timeout","Number","undefined","String","Function","options","suiteFn","decipherOverloadedParameters","only","skip","unreachable","that","describeFn","beforeAllFns","afterAllFns","beforeEachFns","afterEachFns","pushTest","test","push","result","optionalName","optionalOptions","fn","describe","it","testCaseFn","TestCase","beforeAll","defineBeforeAfterFn","afterAll","beforeEach","afterEach","pop","beforeAfterArray","optionsOrFnAsync","possibleFnAsync","fnAsync","constructor","some","_isDotOnly","every","_isSkipped","runAsync","config","notifyFn","clock","create","Object","_recursiveRunAsync","parentMark","parentBeforeEachFns","parentAfterEachFns","myMark","beforeResult","runBeforeOrAfterFnsAsync","isSuccess","results","afterResult","_testFn","optionsOrTestFn","possibleTestFn","inheritedMark","runTestAsync","fail","self","itResult","runTestFnAsync","_error","beforeAfter","pass","testTimeout","getConfig","Error","timeoutAsync","status","startTest","length","currentContext","functionName"],"mappings":"AAAA,iFAAiF;AAEjF,YAAYA,YAAY,oBAAoB;AAC5C,SAASC,KAAK,QAAQ,6BAA6B;AACnD,SAAyBC,QAAQ,EAAiBC,UAAU,EAAEC,UAAU,QAAyB,mBAAmB;AACpH,OAAOC,UAAU,YAAY;AAE7B,wGAAwG;AACxG,mFAAmF;AAGnF,MAAMC,wBAAwB;AAwF9B,MAAMC,cAA6B,EAAE;AAErC;;CAEC,GACD,OAAO,MAAMC;IAEJC,MAAc;IACdC,MAAqB;IACrBC,OAAmB;IACnBC,oBAA6B;IAC7BC,oBAA6B;IAC7BC,cAAuC;IACvCC,aAAsC;IACtCC,eAAwC;IACxCC,cAAuC;IACvCC,SAAwB;IACxBC,UAAmB;IAE3B,WAAWb,wBAAwB;QAClC,OAAOA;IACR;IAEA;;;;;EAKC,GACD,aAAac,iBAAiBC,eAAyB,EAAsB;QAC5ErB,OAAOsB,SAAS,CAACC,WAAW;YAAEC;SAAO;QAErC,MAAMC,SAAS,MAAMC,QAAQC,GAAG,CAACN,gBAAgBO,GAAG,CAACC,CAAAA,WAAYC,gBAAgBD;QACjF,OAAO,IAAIrB,UAAU,IAAIN,SAAS6B,IAAI,EAAE;YAAEC,OAAOP;QAAO;QAExD,eAAeK,gBAAgBD,QAAgB;YAC9C,MAAMI,YAAY,CAAC,qBAAqB,EAAE5B,KAAK6B,QAAQ,CAACL,UAAU,CAAC;YAEnE,IAAI,CAACxB,KAAK8B,UAAU,CAACN,WAAW;gBAC/B,OAAOO,cAAcH,WAAW,CAAC,+CAA+C,EAAEJ,SAAS,CAAC;YAC7F;YACA,IAAI;gBACH,MAAM,EAAEQ,SAASC,KAAK,EAAE,GAAG,MAAM,MAAM,CAACT;gBACxC,IAAIS,iBAAiB9B,WAAW;oBAC/B8B,MAAMC,YAAY,CAACV;oBACnB,OAAOS;gBACR,OACK;oBACJ,OAAOF,cAAcH,WAAW,CAAC,yCAAyC,EAAEJ,SAAS,CAAC,EAAEA;gBACzF;YACD,EACA,OAAMW,KAAK;gBACV,MAAMC,OAAQD,KAA0BC;gBACxC,IAAIA,SAAS,wBAAwB;oBACpC,OAAOL,cAAcH,WAAW,CAAC,uBAAuB,EAAEJ,SAAS,CAAC,EAAEA;gBACvE,OACK;oBACJ,OAAOO,cAAcH,WAAWO,KAAKX;gBACtC;YACD;QACD;QAEA,SAASO,cAAcM,IAAY,EAAEC,KAAc,EAAEd,QAAiB;YACrE,OAAO,IAAIrB,UAAU,IAAIN,SAAS6B,IAAI,EAAE;gBAAEC,OAAO;oBAAE,IAAIY,gBAAgBF,MAAMC,OAAOd;iBAAW;YAAC;QACjG;IACD;IAEA,aAAa,GACb,OAAOgB,QACNC,sBAAyE,EACzEC,gBAA0D,EAC1DC,eAAuC,EACvCC,IAAmB,EACP;QACZ,MAAMC,sBAAsB;YAAEC,SAASC;QAAO;QAC9CpD,OAAOsB,SAAS,CAACC,WAAW;YAC3B;gBAAE8B;gBAAWH;gBAAqBI;gBAAQC;aAAU;YACpD;gBAAEF;gBAAWH;gBAAqBK;aAAU;YAC5C;gBAAEF;gBAAWE;aAAU;YACvBD;SACA;QAED,MAAM,EAAEZ,IAAI,EAAEc,OAAO,EAAEC,OAAO,EAAE,GAAGC;QAEnC,IAAID,YAAYJ,WAAW;YAC1B,OAAO,IAAI,CAAC,CAAA,mBAAoB,CAACI,SAASf,MAAMO,MAAMO,QAAQL,OAAO;QACtE,OACK,IAAIF,SAAS/C,SAASyD,IAAI,EAAE;YAChC,OAAO,IAAInD,UAAUkC,MAAMO,MAAM;gBAChCjB,OAAO;oBAAE,IAAIY,gBAAgBF,MAAM;iBAAkD;YACtF;QACD,OACK;YACJ,OAAO,IAAIlC,UAAUkC,MAAMxC,SAAS0D,IAAI,EAAE;gBAAET,SAASK,QAAQL,OAAO;YAAC;QACtE;QAEA,SAASO;YACR,IAAIhB;YACJ,IAAIc;YACJ,IAAIC;YAEJ,OAAQ,OAAOX;gBACd,KAAK;oBACJJ,OAAOI;oBACP;gBACD,KAAK;oBACJU,UAAUV;oBACV;gBACD,KAAK;oBACJW,UAAUX;oBACV;gBACD,KAAK;oBACJ;gBACD;oBACC9C,OAAO6D,WAAW,CAAC,CAAC,2CAA2C,EAAE,OAAOf,uBAAuB,CAAC;YAClG;YACA,OAAQ,OAAOC;gBACd,KAAK;oBACJ/C,OAAO8D,IAAI,CAACN,YAAYH,WAAW;oBACnCG,UAAUT;oBACV;gBACD,KAAK;oBACJ/C,OAAO8D,IAAI,CAACL,YAAYJ,WAAW;oBACnCI,UAAUV;oBACV;gBACD,KAAK;oBACJ;gBACD;oBACC/C,OAAO6D,WAAW,CAAC,CAAC,qCAAqC,EAAE,OAAOd,iBAAiB,CAAC;YACtF;YACA,IAAIC,oBAAoBK,WAAW;gBAClCrD,OAAO8D,IAAI,CAACL,YAAYJ,WAAW;gBACnCI,UAAUT;YACX;YAEAN,SAAS;YACTc,YAAY,CAAC;YAEb,OAAO;gBAAEd;gBAAMc;gBAASC;YAAQ;QACjC;IACD;IAEA,OAAO,CAAA,mBAAoB,CAC1BM,UAAsB,EACtBrB,IAAY,EACZO,IAAmB,EACnBE,OAAsB;QAEtB,MAAMnB,QAAoB,EAAE;QAC5B,MAAMgC,eAAwC,EAAE;QAChD,MAAMC,cAAuC,EAAE;QAC/C,MAAMC,gBAAyC,EAAE;QACjD,MAAMC,eAAwC,EAAE;QAEhD,MAAMC,WAAW,CAAqBC;YACrCrC,MAAMsC,IAAI,CAACD;YACX,OAAOA;QACR;QAEA,MAAME,SAAmB,CAACC,cAAcC,iBAAiBC,KAAO,IAAI,CAAC7B,OAAO,CAAC2B,cAAcC,iBAAiBC,IAAIxE,SAAS6B,IAAI;QAC7HwC,OAAOX,IAAI,GAAG,CAACY,cAAcC,iBAAiBC,KAAO,IAAI,CAAC7B,OAAO,CAAC2B,cAAcC,iBAAiBC,IAAIxE,SAAS0D,IAAI;QAClHW,OAAOZ,IAAI,GAAG,CAACa,cAAcC,iBAAiBC,KAAO,IAAI,CAAC7B,OAAO,CAAC2B,cAAcC,iBAAiBC,IAAIxE,SAASyD,IAAI;QAElH,MAAMgB,WAAqB,CAACH,cAAcC,iBAAiBC,KAAON,SAAS5D,UAAUqC,OAAO,CAAC2B,cAAcC,iBAAiBC,IAAIxE,SAAS6B,IAAI;QAC7I4C,SAASf,IAAI,GAAG,CAACY,cAAcC,iBAAiBC,KAAON,SAAS5D,UAAUqC,OAAO,CAAC2B,cAAcC,iBAAiBC,IAAIxE,SAAS0D,IAAI;QAClIe,SAAShB,IAAI,GAAG,CAACa,cAAcC,iBAAiBC,KAAON,SAAS5D,UAAUqC,OAAO,CAAC2B,cAAcC,iBAAiBC,IAAIxE,SAASyD,IAAI;QAElI,MAAMiB,KAAS,CAAClC,MAAM+B,iBAAiBI,aAAeT,SAAS,IAAIU,SAASpC,MAAM+B,iBAAiBI,YAAY3E,SAAS6B,IAAI;QAC5H6C,GAAGhB,IAAI,GAAG,CAAClB,MAAM+B,iBAAiBI,aAAeT,SAAS,IAAIU,SAASpC,MAAM+B,iBAAiBI,YAAY3E,SAAS0D,IAAI;QACvHgB,GAAGjB,IAAI,GAAG,CAACjB,MAAM+B,iBAAiBI,aAAeT,SAAS,IAAIU,SAASpC,MAAM+B,iBAAiBI,YAAY3E,SAASyD,IAAI;QAEvHpD,YAAY+D,IAAI,CAAC;YAChBK;YACAC;YACAG,WAAWC,oBAAoBhB;YAC/BiB,UAAUD,oBAAoBf;YAC9BiB,YAAYF,oBAAoBd;YAChCiB,WAAWH,oBAAoBb;QAChC;QACA,IAAI;YACHJ;QACD,SACQ;YACPxD,YAAY6E,GAAG;QAChB;QAEA,OAAO,IAAI5E,UAAUkC,MAAMO,MAAM;YAAEjB;YAAOgC;YAAcC;YAAaC;YAAeC;YAAchB;QAAQ;QAE1G,SAAS6B,oBAAoBK,gBAAyC;YACrE,OAAO,SAAUC,gBAAkC,EAAEC,eAAsB;gBAC1EvF,OAAOsB,SAAS,CAACC,WAAW;oBAC3B;wBAAE;4BAAE4B,SAASC;wBAAO;wBAAGG;qBAAU;oBACjC;wBAAEF;wBAAWE;qBAAU;iBACvB;gBAED,IAAIC;gBACJ,IAAIgC;gBAEJ,IAAID,oBAAoBlC,WAAW;oBAClCG,UAAU,CAAC;oBACXgC,UAAUF;gBACX,OACK;oBACJ9B,UAAU8B;oBACVE,UAAUD;gBACX;gBAEAF,iBAAiBf,IAAI,CAAC;oBAAEd;oBAASgC;gBAAQ;YAC1C;QACD;IACD;IAEA,qGAAqG,GACrGC,YAAY/C,IAAY,EAAEO,IAAmB,EAAE,EAC9CjB,QAAQ,EAAE,EACVgC,eAAe,EAAE,EACjBC,cAAc,EAAE,EAChBC,gBAAgB,EAAE,EAClBC,eAAe,EAAE,EACjBhB,OAAO,EAQP,CAAE;QACF,IAAI,CAAC1C,KAAK,GAAGiC;QACb,IAAI,CAAChC,KAAK,GAAGuC;QACb,IAAI,CAACtC,MAAM,GAAGqB;QACd,IAAI,CAACpB,mBAAmB,GAAG,IAAI,CAACD,MAAM,CAAC+E,IAAI,CAACrB,CAAAA,OAAQA,KAAKsB,UAAU;QACnE,IAAI,CAAC9E,mBAAmB,GAAG,IAAI,CAACF,MAAM,CAACiF,KAAK,CAACvB,CAAAA,OAAQA,KAAKwB,UAAU,CAAC,IAAI,CAACnF,KAAK;QAC/E,IAAI,CAACI,aAAa,GAAGkD;QACrB,IAAI,CAACjD,YAAY,GAAGkD;QACpB,IAAI,CAACjD,cAAc,GAAGkD;QACtB,IAAI,CAACjD,aAAa,GAAGkD;QACrB,IAAI,CAACjD,QAAQ,GAAGiC;IACjB;IAEA;;;;;;;;EAQC,GACD,MAAM2C,SAAS,EACd3C,UAAU7C,qBAAqB,EAC/ByF,SAAS,CAAC,CAAC,EACXC,WAAW,KAAO,CAAC,EACnBC,QAAQhG,MAAMiG,MAAM,EAAE,EACT,GAAG,CAAC,CAAC,EAA4B;QAC9ClG,OAAOsB,SAAS,CAACC,WAAW;YAAC;gBAAE8B;gBAAW;oBACzCF,SAAS;wBAAEE;wBAAWD;qBAAQ;oBAC9B2C,QAAQ;wBAAE1C;wBAAW8C;qBAAQ;oBAC7BH,UAAU;wBAAE3C;wBAAWE;qBAAU;oBACjC0C,OAAO;wBAAE5C;wBAAWpD;qBAAO;gBAC5B;aAAE;SAAC;QAEH,OAAO,MAAM,IAAI,CAACmG,kBAAkB,CAAClG,SAASyD,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE;YAC3DsC;YACAF;YACAC;YACAtD,MAAM,EAAE;YACRb,UAAU,IAAI,CAACV,SAAS;YACxBgC,SAAS,IAAI,CAACjC,QAAQ,IAAIiC,WAAW7C;QACtC;IACD;IAEA,aAAa,GACbiC,aAAaV,QAAgB,EAAE;QAAE,IAAI,CAACV,SAAS,GAAGU;IAAU;IAE5D,aAAa,GACb8D,aAAsB;QACrB,OAAO,IAAI,CAACjF,KAAK,KAAKR,SAASyD,IAAI,IAAI,IAAI,CAAC/C,mBAAmB;IAChE;IAEA,aAAa,GACbiF,aAAsB;QACrB,OAAO,IAAI,CAAChF,mBAAmB;IAChC;IAEA,aAAa,GACb,MAAMuF,mBACLC,UAAyB,EACzBC,mBAA4C,EAC5CC,kBAA2C,EAC3C/C,OAA4B,EAC3B;QACD,MAAMd,OAAO;eAAKc,QAAQd,IAAI;SAAE;QAChC,IAAI,IAAI,CAACjC,KAAK,KAAK,IAAIiC,KAAK4B,IAAI,CAAC,IAAI,CAAC7D,KAAK;QAC3C,MAAMoB,WAAW,IAAI,CAACV,SAAS,IAAIqC,QAAQ3B,QAAQ;QACnD,MAAMsB,UAAU,IAAI,CAACjC,QAAQ,IAAIsC,QAAQL,OAAO;QAChDK,UAAU;YAAE,GAAGA,OAAO;YAAEd;YAAMb;YAAUsB;QAAQ;QAEhD,IAAIqD,SAAS,IAAI,CAAC9F,KAAK;QACvB,IAAI8F,WAAWtG,SAAS6B,IAAI,EAAEyE,SAASH;QACvC,IAAIG,WAAWtG,SAASyD,IAAI,IAAI,IAAI,CAAC/C,mBAAmB,EAAE4F,SAAStG,SAAS0D,IAAI;QAEhF,MAAMM,gBAAgB;eAAKoC;eAAwB,IAAI,CAACtF,cAAc;SAAE;QACxE,MAAMmD,eAAe;eAAK,IAAI,CAAClD,aAAa;eAAKsF;SAAoB;QAErE,IAAI,CAAC,IAAI,CAAC1F,mBAAmB,EAAE;YAC9B,MAAM4F,eAAe,MAAMC,yBAC1B;mBAAKlD,QAAQd,IAAI;gBAAE;aAAe,EAAE,IAAI,CAAC5B,aAAa,EAAEZ,SAAS6B,IAAI,EAAEyB;YAExE,IAAI,CAACmD,UAAUF,eAAe,OAAOtG,WAAWmC,KAAK,CAACkB,QAAQd,IAAI,EAAE;gBAAE+D;aAAc,EAAEjD,QAAQ3B,QAAQ,EAAE,IAAI,CAACnB,KAAK;QACnH;QAEA,MAAMkG,UAAU,EAAE;QAClB,WAAW,MAAMvC,QAAQ,IAAI,CAAC1D,MAAM,CAAE;YACrCiG,QAAQtC,IAAI,CAAC,MAAMD,KAAK+B,kBAAkB,CAACI,QAAQtC,eAAeC,cAAcX;QACjF;QAEA,IAAI,CAAC,IAAI,CAAC3C,mBAAmB,EAAE;YAC9B,MAAMgG,cAAc,MAAMH,yBACzB;mBAAKlD,QAAQd,IAAI;gBAAE;aAAc,EAAE,IAAI,CAAC3B,YAAY,EAAEb,SAAS6B,IAAI,EAAEyB;YAEtE,IAAI,CAACmD,UAAUE,cAAcD,QAAQtC,IAAI,CAACuC;QAC3C;QAEA,OAAO1G,WAAWmC,KAAK,CAACkB,QAAQd,IAAI,EAAEkE,SAASpD,QAAQ3B,QAAQ,EAAE,IAAI,CAACnB,KAAK;IAC5E;AAED;AAGA,MAAMoE;IAEKrE,MAAc;IAChBS,SAAwB;IACxB4F,QAAe;IACfpG,MAAqB;IAE7B+E,YACC/C,IAAY,EACZqE,eAA+C,EAC/CC,cAAgC,EAChC/D,IAAmB,CAClB;QACDjD,OAAOsB,SAAS,CAACC,WAAW;YAC3B+B;YACA;gBAAED;gBAAW;oBAAEF,SAAS;wBAAEE;wBAAWD;qBAAQ;gBAAA;gBAAGG;aAAU;YAC1D;gBAAEF;gBAAWE;aAAU;YACvBD;SACA;QAED,IAAI,CAAC7C,KAAK,GAAGiC;QAEb,OAAQ,OAAOqE;YACd,KAAK;gBACJ,IAAI,CAAC7F,QAAQ,GAAG6F,gBAAgB5D,OAAO;gBACvC;YACD,KAAK;gBACJ,IAAI,CAAC2D,OAAO,GAAGC;gBACf;YACD,KAAK;gBACJ;YACD;gBACC/G,OAAO6D,WAAW,CAAC,CAAC,gCAAgC,EAAE,OAAOkD,gBAAgB,CAAC;QAChF;QACA,IAAIC,mBAAmB3D,WAAW;YACjCrD,OAAO8D,IAAI,CAAC,IAAI,CAACgD,OAAO,KAAKzD,WAAW;YACxC,IAAI,CAACyD,OAAO,GAAGE;QAChB;QAEA,IAAI,CAACtG,KAAK,GAAGuC;IACd;IAEA,aAAa,GACb0C,aAAsB;QACrB3F,OAAOsB,SAAS,CAACC,WAAW,EAAE;QAC9B,OAAO,IAAI,CAACb,KAAK,KAAKR,SAASyD,IAAI;IACpC;IAEA,aAAa,GACbkC,WAAWQ,UAAyB,EAAW;QAC9C,MAAMY,gBAAgB,IAAI,CAACvG,KAAK,KAAKR,SAAS6B,IAAI,GAAGsE,aAAa,IAAI,CAAC3F,KAAK;QAC5E,OAAOuG,kBAAkB/G,SAAS0D,IAAI;IACvC;IAEA,aAAa,GACb,MAAMwC,mBACLC,UAAyB,EACzBnC,aAAsC,EACtCC,YAAqC,EACrCX,OAA4B,EACF;QAC1B,MAAMd,OAAO;eAAKc,QAAQd,IAAI;SAAE;QAChCA,KAAK4B,IAAI,CAAC,IAAI,CAAC7D,KAAK,KAAK,KAAK,IAAI,CAACA,KAAK,GAAG;QAC3C+C,UAAU;YAAE,GAAGA,OAAO;YAAEd;QAAK;QAE7B,IAAI6B;QACJ,IAAI,IAAI,CAACuC,OAAO,KAAKzD,WAAW;YAC/B,IAAI,CAAC,IAAI,CAACwC,UAAU,CAACQ,aAAa;gBACjC9B,SAAS,MAAM2C,aAAa,IAAI;YACjC,OACK;gBACJ3C,SAASpE,WAAWyD,IAAI,CAAClB,MAAMc,QAAQ3B,QAAQ,EAAE,IAAI,CAACnB,KAAK;YAC5D;QACD,OACK;YACJ,IAAI,IAAI,CAACA,KAAK,KAAKR,SAASyD,IAAI,EAAE;gBACjCY,SAASpE,WAAWyD,IAAI,CAAClB,MAAMc,QAAQ3B,QAAQ,EAAE3B,SAAS0D,IAAI;YAC/D,OACK;gBACJW,SAASpE,WAAWgH,IAAI,CAACzE,MAAM,8CAA8Cc,QAAQ3B,QAAQ,EAAE,IAAI,CAACnB,KAAK;YAC1G;QACD;QAEA8C,QAAQwC,QAAQ,CAACzB;QACjB,OAAOA;QAEP,eAAe2C,aAAaE,IAAc;YACzC,MAAMX,eAAe,MAAMC,yBAAyBlD,QAAQd,IAAI,EAAEwB,eAAekD,KAAK1G,KAAK,EAAE8C;YAC7F,IAAI,CAACmD,UAAUF,eAAe,OAAOA;YAErC,MAAMY,WAAW,MAAMC,eAAe9D,QAAQd,IAAI,EAAE0E,KAAKN,OAAO,EAAGM,KAAK1G,KAAK,EAAE0G,KAAKlG,QAAQ,EAAEsC;YAC9F,MAAMqD,cAAc,MAAMH,yBAAyBlD,QAAQd,IAAI,EAAEyB,cAAciD,KAAK1G,KAAK,EAAE8C;YAE3F,IAAI,CAACmD,UAAUU,WAAW,OAAOA;iBAC5B,OAAOR;QACb;IACD;AACD;AAGA,MAAMjE,wBAAwBkC;IAErB3D,UAAmB;IACnBoG,OAAgB;IAExB9B,YAAY/C,IAAY,EAAEC,KAAc,EAAEd,QAAiB,CAAE;QAC5D,KAAK,CAACa,MAAMW,WAAWA,WAAWnD,SAAS6B,IAAI;QAE/C,IAAI,CAACZ,SAAS,GAAGU;QACjB,IAAI,CAAC0F,MAAM,GAAG5E;IACf;IAEA,MAAeyD,mBACdC,UAAyB,EACzBnC,aAAsC,EACtCC,YAAqC,EACrCX,OAA4B,EACF;QAC1B,MAAMe,SAASpE,WAAWgH,IAAI,CAAC;YAAE,IAAI,CAAC1G,KAAK;SAAE,EAAE,IAAI,CAAC8G,MAAM,EAAE,IAAI,CAACpG,SAAS;QAC1EqC,QAAQwC,QAAQ,CAACzB;QACjB,OAAO,MAAMA;IACd;AAED;AAGA,eAAemC,yBACdhE,IAAc,EACd2C,gBAAyC,EACzCpC,IAAmB,EACnBO,OAA4B;IAE5B,WAAW,MAAMgE,eAAenC,iBAAkB;QACjD,MAAMd,SAAS,MAAM+C,eAAe5E,MAAM8E,YAAYhC,OAAO,EAAEvC,MAAMuE,YAAYhE,OAAO,CAACL,OAAO,EAAEK;QAClG,IAAI,CAACmD,UAAUpC,SAAS,OAAOA;IAChC;IACA,OAAOpE,WAAWsH,IAAI,CAAC/E,MAAMc,QAAQ3B,QAAQ,EAAEoB;AAChD;AAEA,eAAeqE,eACd5E,IAAc,EACdgC,EAAQ,EACRzB,IAAmB,EACnByE,WAAqC,EACrC,EAAEzB,KAAK,EAAEpE,QAAQ,EAAEsB,OAAO,EAAE4C,MAAM,EAAuB;IAEzD,MAAM4B,YAAY,CAAIjF;QACrB,IAAIqD,MAAM,CAACrD,KAAK,KAAKW,WAAW,MAAM,IAAIuE,MAAM,CAAC,+BAA+B,EAAElF,KAAK,CAAC,CAAC;QACzF,OAAOqD,MAAM,CAACrD,KAAK;IACpB;IAEAS,UAAUuE,eAAevE;IAEzB,OAAO,MAAM8C,MAAM4B,YAAY,CAAC1E,SAAS;QACxC,IAAI;YACH,MAAMuB,GAAG;gBAAEiD;YAAU;YACrB,OAAOxH,WAAWsH,IAAI,CAAC/E,MAAMb,UAAUoB;QACxC,EACA,OAAOT,KAAK;YACX,OAAOrC,WAAWgH,IAAI,CAACzE,MAAMF,KAAKX,UAAUoB;QAC7C;IACD,GAAG;QACF,OAAO,MAAM9C,WAAWgD,OAAO,CAACT,MAAMS,SAAStB,UAAUoB;IAC1D;AACD;AAEA,SAAS0D,UAAUpC,MAAsB;IACxC,OAAOA,OAAOuD,MAAM,KAAK1H,WAAWqH,IAAI,IAAIlD,OAAOuD,MAAM,KAAK1H,WAAWwD,IAAI;AAC9E;AAGA,SAASmE,UACRvD,YAA+D,EAC/DC,eAAyD,EACzDC,EAA0B,EAC1BzB,IAAmB;IAEnBjD,OAAO8D,IAAI,CAACvD,YAAYyH,MAAM,KAAK,GAAG;IAEtC,IAAI;QACH,OAAOxH,UAAUqC,OAAO,CAAC2B,cAAcC,iBAAiBC,IAAIzB;IAC7D,SACQ;QACPjD,OAAO8D,IAAI,CAACvD,YAAYyH,MAAM,KAAK,GAAG;IACvC;AACD;AAEA;;;;;;;;;;;;CAYC,GACD,OAAO,SAAS3D,KACfG,YAAoD,EACpDC,eAA8C,EAC9CC,EAAe;IAEf,OAAOqD,UAAUvD,cAAcC,iBAAiBC,IAAIxE,SAAS6B,IAAI;AAClE;AAEAsC,KAAKT,IAAI,GAAG,SACXY,YAAoD,EACpDC,eAA8C,EAC9CC,EAAe;IAEf,OAAOqD,UAAUvD,cAAcC,iBAAiBC,IAAIxE,SAAS0D,IAAI;AAClE;AAEAS,KAAKV,IAAI,GAAG,SACXa,YAAoD,EACpDC,eAA8C,EAC9CC,EAAe;IAEf,OAAOqD,UAAUvD,cAAcC,iBAAiBC,IAAIxE,SAASyD,IAAI;AAClE;AAEA;;;;;;;;;;;CAWC,GACD,OAAO,SAASgB,SACfH,YAAoD,EACpDC,eAA8C,EAC9CC,EAAe;IAEfuD,eAAe,YAAYtD,QAAQ,CAACH,cAAcC,iBAAiBC;AACpE;AAEAC,SAASf,IAAI,GAAG,SACfY,YAAoD,EACpDC,eAA8C,EAC9CC,EAAe;IAEfuD,eAAe,YAAYtD,QAAQ,CAACf,IAAI,CAACY,cAAcC,iBAAiBC;AACzE;AAEAC,SAAShB,IAAI,GAAG,SACfa,YAAoD,EACpDC,eAA8C,EAC9CC,EAAe;IAEfuD,eAAe,YAAYtD,QAAQ,CAAChB,IAAI,CAACa,cAAcC,iBAAiBC;AACzE;AAEA;;;;;;;CAOC,GACD,OAAO,SAASE,GAAGlC,IAAY,EAAE+B,eAAkC,EAAEe,OAAc;IAClFyC,eAAe,MAAMrD,EAAE,CAAClC,MAAM+B,iBAAiBe;AAChD;AAEAZ,GAAGhB,IAAI,GAAG,SAASgB,GAAGlC,IAAY,EAAE+B,eAAkC,EAAEe,OAAc;IACrFyC,eAAe,MAAMrD,EAAE,CAAChB,IAAI,CAAClB,MAAM+B,iBAAiBe;AACrD;AAEAZ,GAAGjB,IAAI,GAAG,SAASiB,GAAGlC,IAAY,EAAE+B,eAAkC,EAAEe,OAAc;IACrFyC,eAAe,MAAMrD,EAAE,CAACjB,IAAI,CAACjB,MAAM+B,iBAAiBe;AACrD;AAEA;;;;;;CAMC,GACD,OAAO,SAAST,UAAUN,eAAiC,EAAEe,OAAc;IAC1EyC,eAAe,aAAalD,SAAS,CAACN,iBAAiBe;AACxD;AAEA;;;;;;CAMC,GACD,OAAO,SAASP,SAASR,eAAiC,EAAEe,OAAc;IACzEyC,eAAe,YAAYhD,QAAQ,CAACR,iBAAiBe;AACtD;AAEA;;;;;;CAMC,GACD,OAAO,SAASN,WAAWT,eAAiC,EAAEe,OAAc;IAC3EyC,eAAe,cAAc/C,UAAU,CAACT,iBAAiBe;AAC1D;AAEA;;;;;;CAMC,GACD,OAAO,SAASL,UAAUV,eAAiC,EAAEe,OAAc;IAC1EyC,eAAe,aAAa9C,SAAS,CAACV,iBAAiBe;AACxD;AAEA,SAASyC,eAAeC,YAAoB;IAC3ClI,OAAO8D,IAAI,CAACvD,YAAYyH,MAAM,GAAG,GAAG,CAAC,EAAEE,aAAa,4BAA4B,CAAC;IAEjF,OAAO3H,WAAW,CAACA,YAAYyH,MAAM,GAAG,EAAE;AAC3C"}