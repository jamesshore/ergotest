{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/test_suite.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\n\nimport * as ensure from \"../util/ensure.js\";\nimport { Clock } from \"../infrastructure/clock.js\";\nimport { TestCaseResult, TestResult, TestStatus, TestSuiteResult } from \"./test_result.js\";\nimport path from \"node:path\";\n\n// A simple but full-featured test runner. It allows me to get away from Mocha's idiosyncracies and have\n// more control over test execution, while also shielding me from dependency churn.\n\n\nconst DEFAULT_TIMEOUT_IN_MS = 2000;\n\nexport const TestMark = {\n\tnone: \"none\",\n\tskip: \"skip\",\n\tonly: \"only\",\n};\n\nexport type TestMarkValue = typeof TestMark[keyof typeof TestMark];\n\ninterface Describe {\n\t(optionalName?: string | DescribeFunction, describeFn?: DescribeFunction): TestSuite,\n\tskip: (optionalName?: string | DescribeFunction, descrbeFn?: DescribeFunction) => TestSuite,\n\tonly: (optionalName?: string | DescribeFunction, describeFn?: DescribeFunction) => TestSuite,\n}\n\ninterface It {\n\t(name: string, itFn?: ItFn): void;\n\tskip: (name: string, itFn?: ItFn) => void,\n\tonly: (name: string, itFn?: ItFn) => void,\n}\n\ntype BeforeAfter = (fn: Test) => void;\n\nexport interface SuiteParameters {\n\tdescribe: Describe,\n\tit: It,\n\tbeforeAll: BeforeAfter,\n\tafterAll: BeforeAfter,\n\tbeforeEach: BeforeAfter,\n\tafterEach: BeforeAfter,\n\tsetTimeout: (newTimeout: Milliseconds) => void,\n}\n\nexport interface TestParameters {\n\tgetConfig: <T>(name: string) => T,\n}\n\nexport type DescribeFunction = (suiteUtilities: SuiteParameters) => void;\nexport type Test = (testUtilities: TestParameters) => Promise<void> | void;\nexport type ItFn = Test;\nexport type BeforeAfterFn = Test;\ntype Milliseconds = number;\n\nexport interface TestConfig {\n\t[name: string]: unknown,\n}\n\ninterface RecursiveRunOptions {\n\tname: string[];\n\tfilename?: string;\n\tclock: Clock,\n\tnotifyFn: (result: TestResult) => void,\n\ttimeout: Milliseconds,\n\tconfig: TestConfig,\n}\n\n\ninterface Runnable {\n\t_recursiveRunAsync: (\n\t\tparentMark: TestMarkValue,\n\t\tparentBeforeEachFns: Test[],\n\t\tparentAfterEachFns: Test[],\n\t\toptions: RecursiveRunOptions,\n\t) => Promise<TestResult> | TestResult;\n\t_isDotOnly: () => boolean,\n\t_isSkipped: (mark: TestMarkValue) => boolean,\n}\n\n/**\n * A simple but full-featured test runner. It's notable for not using globals.\n */\nexport class TestSuite implements Runnable {\n\n\tstatic get DEFAULT_TIMEOUT_IN_MS() {\n\t\treturn DEFAULT_TIMEOUT_IN_MS;\n\t}\n\n\t/**\n\t * @returns {function} A function for creating a test suite. In your test module, call this function and export the\n\t *   result.\n\t */\n\tstatic get create(): Describe {\n\t\tconst result: Describe = (optionalName, suiteFn) => this.#create(optionalName, suiteFn, TestMark.none);\n\t\tresult.skip = (optionalName, suiteFn) => this.#create(optionalName, suiteFn, TestMark.skip);\n\t\tresult.only = (optionalName, suiteFn) => this.#create(optionalName, suiteFn, TestMark.only);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Convert a list of test modules into a test suite. Each module needs to export a test suite by using\n\t * {@link TestSuite.create}.\n\t * @param {string[]} moduleFilenames The filenames of the test modules.\n\t * @returns {TestSuite} The test suite.\n\t */\n\tstatic async fromModulesAsync(moduleFilenames: string[]): Promise<TestSuite> {\n\t\tensure.signature(arguments, [ Array ]);\n\n\t\tconst suites = await Promise.all(moduleFilenames.map(filename => loadModuleAsync(filename)));\n\t\treturn new TestSuite(\"\", TestMark.none, { tests: suites });\n\n\t\tasync function loadModuleAsync(filename: string): Promise<TestSuite> {\n\t\t\tconst errorName = `error when requiring ${path.basename(filename)}`;\n\t\t\ttry {\n\t\t\t\tconst { default: suite } = await import(filename);\n\t\t\t\tif (suite instanceof TestSuite) {\n\t\t\t\t\tsuite._setFilename(filename);\n\t\t\t\t\treturn suite;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn createFailure(errorName, `doesn't export a test suite: ${filename}`, filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(err) {\n\t\t\t\treturn createFailure(errorName, err, filename);\n\t\t\t}\n\t\t}\n\n\t\tfunction createFailure(name: string, error: unknown, filename?: string) {\n\t\t\treturn new TestSuite(\"\", TestMark.none, { tests: [ new FailureTestCase(name, error, filename) ] });\n\t\t}\n\t}\n\n\tstatic #create(\n\t\tnameOrSuiteFn: string | DescribeFunction | undefined,\n\t\tpossibleSuiteFn: DescribeFunction | undefined,\n\t\tmark: TestMarkValue,\n\t): TestSuite {\n\t\tensure.signature(arguments, [ [ undefined, String, Function ], [ undefined, Function ], String ]);\n\n\t\tlet name: string;\n\t\tlet suiteFn: DescribeFunction | undefined;\n\n\t\tif (nameOrSuiteFn instanceof Function || (nameOrSuiteFn === undefined && possibleSuiteFn === undefined)) {\n\t\t\tname = \"\";\n\t\t\tsuiteFn = nameOrSuiteFn;\n\t\t}\n\t\telse {\n\t\t\tname = nameOrSuiteFn ?? \"\";\n\t\t\tsuiteFn = possibleSuiteFn;\n\t\t}\n\n\t\tif (suiteFn !== undefined) {\n\t\t\treturn this.#runDescribeFunction(suiteFn, name, mark);\n\t\t}\n\t\telse if (mark === TestMark.only) {\n\t\t\treturn new TestSuite(name, mark, {\n\t\t\t\ttests: [ new FailureTestCase(name, \"Test suite is marked '.only', but has no body\") ],\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn new TestSuite(name, TestMark.skip, {});\n\t\t}\n\t}\n\n\tstatic #runDescribeFunction(\n\t\tdescribeFn: DescribeFunction,\n\t\tname: string,\n\t\tmark: string,\n\t): TestSuite {\n\t\tconst tests: Runnable[] = [];\n\t\tconst beforeAllFns: Test[] = [];\n\t\tconst afterAllFns: Test[] = [];\n\t\tconst beforeEachFns: Test[] = [];\n\t\tconst afterEachFns: Test[] = [];\n\t\tlet timeout: number | undefined;\n\n\t\tconst pushTest = <T extends Runnable>(test: T): T => {\n\t\t\ttests.push(test);\n\t\t\treturn test;\n\t\t};\n\n\t\tconst result: Describe = (optionalName, suiteFn) => this.#create(optionalName, suiteFn, TestMark.none);\n\t\tresult.skip = (optionalName, suiteFn) => this.#create(optionalName, suiteFn, TestMark.skip);\n\t\tresult.only = (optionalName, suiteFn) => this.#create(optionalName, suiteFn, TestMark.only);\n\n\t\tconst describe: Describe = (optionalName, suiteFn) => pushTest(TestSuite.#create(optionalName, suiteFn, TestMark.none));\n\t\tdescribe.skip = (optionalName, describeFn) => pushTest(TestSuite.#create(optionalName, describeFn, TestMark.skip));\n\t\tdescribe.only = (optionalName, suiteFn) => pushTest(TestSuite.#create(optionalName, suiteFn, TestMark.only));\n\n\t\tconst it: It = (name, testCaseFn) => pushTest(new TestCase(name, testCaseFn, TestMark.none));\n\t\tit.skip = (name, testCaseFn) => pushTest(new TestCase(name, testCaseFn, TestMark.skip));\n\t\tit.only = (name, testCaseFn) => pushTest(new TestCase(name, testCaseFn, TestMark.only));\n\n\t\tdescribeFn({\n\t\t\tdescribe,\n\t\t\tit,\n\t\t\tbeforeAll: (fnAsync) => { beforeAllFns.push(fnAsync); },\n\t\t\tafterAll: (fnAsync) => { afterAllFns.push(fnAsync); },\n\t\t\tbeforeEach: (fnAsync) => { beforeEachFns.push(fnAsync); },\n\t\t\tafterEach: (fnAsync) => { afterEachFns.push(fnAsync); },\n\t\t\tsetTimeout: (newTimeout) => { timeout = newTimeout; },\n\t\t});\n\n\t\treturn new TestSuite(name, mark, { tests, beforeAllFns, afterAllFns, beforeEachFns, afterEachFns, timeout });\n\t}\n\n\tprivate _name: string;\n\tprivate _mark: TestMarkValue;\n\tprivate _tests: Runnable[];\n\tprivate _hasDotOnlyChildren: boolean;\n\tprivate _allChildrenSkipped: boolean;\n\tprivate _beforeAllFns: BeforeAfterFn[];\n\tprivate _afterAllFns: BeforeAfterFn[];\n\tprivate _beforeEachFns: BeforeAfterFn[];\n\tprivate _afterEachFns: BeforeAfterFn[];\n\tprivate _timeout?: Milliseconds;\n\tprivate _filename?: string;\n\n\t/** Internal use only. (Use {@link TestSuite.create} or {@link TestSuite.fromModulesAsync} instead.) */\n\tconstructor(name: string, mark: TestMarkValue, {\n\t\ttests = [],\n\t\tbeforeAllFns = [],\n\t\tafterAllFns = [],\n\t\tbeforeEachFns = [],\n\t\tafterEachFns = [],\n\t\ttimeout,\n\t}: {\n\t\ttests?: Runnable[],\n\t\tbeforeAllFns?: BeforeAfterFn[],\n\t\tafterAllFns?: BeforeAfterFn[],\n\t\tbeforeEachFns?: BeforeAfterFn[],\n\t\tafterEachFns?: BeforeAfterFn[],\n\t\ttimeout?: Milliseconds,\n\t}) {\n\n\t\tthis._name = name;\n\t\tthis._mark = mark;\n\t\tthis._tests = tests;\n\t\tthis._hasDotOnlyChildren = this._tests.some(test => test._isDotOnly());\n\t\tthis._allChildrenSkipped = this._tests.every(test => test._isSkipped(this._mark));\n\t\tthis._beforeAllFns = beforeAllFns;\n\t\tthis._afterAllFns = afterAllFns;\n\t\tthis._beforeEachFns = beforeEachFns;\n\t\tthis._afterEachFns = afterEachFns;\n\t\tthis._timeout = timeout;\n\t}\n\n\t/**\n\t * Run the tests in this suite.\n\t * @param {object} [config={}] Configuration data to provide to tests.\n\t * @param {(result: TestResult) => ()} [notifyFn] A function to call each time a test completes. The `result`\n\t *   parameter describes the result of the testâ€”whether it passed, failed, etc.\n\t * @param {Clock} [clock] The clock to use. Meant for internal use.\n\t * @returns {Promise<TestSuiteResult>} The results of the test suite.\n\t */\n\tasync runAsync({\n\t\tconfig = {},\n\t\tnotifyFn = () => {},\n\t\tclock = Clock.create(),\n\t}: {\n\t\tconfig?: TestConfig,\n\t\tnotifyFn?: (result: TestResult) => void,\n\t\tclock?: Clock,\n\t} = {}): Promise<TestSuiteResult> {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\tconfig: [ undefined, Object ],\n\t\t\tnotifyFn: [ undefined, Function ],\n\t\t\tclock: [ undefined, Clock ],\n\t\t}]]);\n\n\t\treturn await this._recursiveRunAsync(TestMark.only, [], [], {\n\t\t\tclock,\n\t\t\tconfig,\n\t\t\tnotifyFn,\n\t\t\tname: [],\n\t\t\tfilename: this._filename,\n\t\t\ttimeout: this._timeout ?? DEFAULT_TIMEOUT_IN_MS,\n\t\t});\n\t}\n\n\t/** @private */\n\t_setFilename(filename: string) { this._filename = filename; }\n\n\t/** @private */\n\t_isDotOnly(): boolean {\n\t\treturn this._mark === TestMark.only || this._hasDotOnlyChildren;\n\t}\n\n\t/** @private */\n\t_isSkipped(): boolean {\n\t\treturn this._allChildrenSkipped;\n\t}\n\n\t/** @private */\n\tasync _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tparentBeforeEachFns: Test[],\n\t\tparentAfterEachFns: Test[],\n\t\toptions: RecursiveRunOptions,\n\t) {\n\t\tconst name = [ ...options.name ];\n\t\tif (this._name !== \"\") name.push(this._name);\n\t\tconst filename = this._filename ?? options.filename;\n\t\tconst timeout = this._timeout ?? options.timeout;\n\t\toptions = { ...options, name, filename, timeout };\n\n\t\tlet myMark = this._mark;\n\t\tif (myMark === TestMark.none) myMark = parentMark;\n\t\tif (myMark === TestMark.only && this._hasDotOnlyChildren) myMark = TestMark.skip;\n\n\t\tconst beforeEachFns = [ ...parentBeforeEachFns, ...this._beforeEachFns ];\n\t\tconst afterEachFns = [ ...this._afterEachFns, ...parentAfterEachFns ];\n\n\t\tif (!this._allChildrenSkipped) {\n\t\t\tconst beforeResult = await runBeforeOrAfterFnsAsync(\n\t\t\t\t[ ...options.name, \"beforeAll()\" ], this._beforeAllFns, TestMark.none, options,\n\t\t\t);\n\t\t\tif (!isSuccess(beforeResult)) return TestResult.suite(options.name, [ beforeResult ], options.filename, this._mark);\n\t\t}\n\n\t\tconst results = [];\n\t\tfor await (const test of this._tests) {\n\t\t\tresults.push(await test._recursiveRunAsync(myMark, beforeEachFns, afterEachFns, options));\n\t\t}\n\n\t\tif (!this._allChildrenSkipped) {\n\t\t\tconst afterResult = await runBeforeOrAfterFnsAsync(\n\t\t\t\t[ ...options.name, \"afterAll()\" ], this._afterAllFns, TestMark.none, options\n\t\t\t);\n\t\t\tif (!isSuccess(afterResult)) results.push(afterResult);\n\t\t}\n\n\t\tconst testSuiteResult = TestResult.suite(options.name, results, options.filename, this._mark);\n\t\treturn testSuiteResult;\n\t}\n\n}\n\n\nclass TestCase implements Runnable {\n\n\tprotected _name: string;\n\tprivate _testFn?: ItFn;\n\tprivate _mark: TestMarkValue;\n\n\tconstructor(name: string, testFn: ItFn | undefined, mark: TestMarkValue) {\n\t\tensure.signature(arguments, [ String, [ undefined, Function ], String ]);\n\n\t\tthis._name = name;\n\t\tthis._testFn = testFn;\n\t\tthis._mark = mark;\n\t}\n\n\t/** @private */\n\t_isDotOnly(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this._mark === TestMark.only;\n\t}\n\n\t/** @private */\n\t_isSkipped(parentMark: TestMarkValue): boolean {\n\t\tconst inheritedMark = this._mark === TestMark.none ? parentMark : this._mark;\n\t\treturn inheritedMark === TestMark.skip;\n\t}\n\n\t/** @private */\n\tasync _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tbeforeEachFns: Test[],\n\t\tafterEachFns: Test[],\n\t\toptions: RecursiveRunOptions,\n\t): Promise<TestCaseResult> {\n\t\tconst name = [ ...options.name ];\n\t\tname.push(this._name !== \"\" ? this._name : \"(unnamed)\");\n\t\toptions = { ...options, name };\n\n\t\tlet result;\n\t\tif (this._testFn !== undefined) {\n\t\t\tif (!this._isSkipped(parentMark)) {\n\t\t\t\tresult = await runTestAsync(this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = TestResult.skip(name, options.filename, this._mark);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this._mark !== TestMark.only) {\n\t\t\t\tresult = TestResult.skip(name, options.filename, TestMark.skip);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = TestResult.fail(name, \"Test is marked '.only', but it has no body\", options.filename, this._mark);\n\t\t\t}\n\t\t}\n\n\t\toptions.notifyFn(result);\n\t\treturn result;\n\n\t\tasync function runTestAsync(self: TestCase): Promise<TestCaseResult> {\n\t\t\tconst beforeResult = await runBeforeOrAfterFnsAsync(options.name, beforeEachFns, self._mark, options);\n\t\t\tif (!isSuccess(beforeResult)) return beforeResult;\n\n\t\t\tconst itResult = await runTestFnAsync(options.name, self._testFn!, self._mark, options);\n\t\t\tconst afterResult = await runBeforeOrAfterFnsAsync(options.name, afterEachFns, self._mark, options);\n\n\t\t\tif (!isSuccess(itResult)) return itResult;\n\t\t\telse return afterResult;\n\t\t}\n\t}\n}\n\n\nclass FailureTestCase extends TestCase {\n\n\tprivate _filename?: string;\n\tprivate _error: unknown;\n\n\tconstructor(name: string, error: unknown, filename?: string) {\n\t\tsuper(name, undefined, TestMark.none);\n\n\t\tthis._filename = filename;\n\t\tthis._error = error;\n\t}\n\n\toverride async _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tbeforeEachFns: Test[],\n\t\tafterEachFns: Test[],\n\t\toptions: RecursiveRunOptions,\n\t): Promise<TestCaseResult> {\n\t\treturn await TestResult.fail([ this._name ], this._error, this._filename);\n\t}\n\n}\n\n\nasync function runBeforeOrAfterFnsAsync(\n\tname: string[],\n\tfns: Test[],\n\tmark: TestMarkValue,\n\toptions: RecursiveRunOptions,\n): Promise<TestCaseResult> {\n\tfor await (const fn of fns) {\n\t\tconst result = await runTestFnAsync(name, fn, mark, options);\n\t\tif (!isSuccess(result)) return result;\n\t}\n\treturn TestResult.pass(name, options.filename, mark);\n}\n\nasync function runTestFnAsync(\n\tname: string[],\n\tfn: Test,\n\tmark: TestMarkValue,\n\t{ clock, filename, timeout, config }: RecursiveRunOptions,\n): Promise<TestCaseResult> {\n\tconst getConfig = <T>(name: string) => {\n\t\tif (config[name] === undefined) throw new Error(`No test config found for name '${name}'`);\n\t\treturn config[name] as T;\n\t};\n\n\treturn await clock.timeoutAsync(timeout, async () => {\n\t\ttry {\n\t\t\tawait fn({ getConfig });\n\t\t\treturn TestResult.pass(name, filename, mark);\n\t\t}\n\t\tcatch (err) {\n\t\t\treturn TestResult.fail(name, err, filename, mark);\n\t\t}\n\t}, async () => {\n\t\treturn await TestResult.timeout(name, timeout, filename, mark);\n\t});\n}\n\nfunction isSuccess(result: TestCaseResult) {\n\treturn result.status === TestStatus.pass || result.status === TestStatus.skip;\n}\n"],"names":["ensure","Clock","TestResult","TestStatus","path","DEFAULT_TIMEOUT_IN_MS","TestMark","none","skip","only","TestSuite","create","result","optionalName","suiteFn","fromModulesAsync","moduleFilenames","signature","arguments","Array","suites","Promise","all","map","filename","loadModuleAsync","tests","errorName","basename","default","suite","_setFilename","createFailure","err","name","error","FailureTestCase","nameOrSuiteFn","possibleSuiteFn","mark","undefined","String","Function","describeFn","beforeAllFns","afterAllFns","beforeEachFns","afterEachFns","timeout","pushTest","test","push","describe","it","testCaseFn","TestCase","beforeAll","fnAsync","afterAll","beforeEach","afterEach","setTimeout","newTimeout","_name","_mark","_tests","_hasDotOnlyChildren","_allChildrenSkipped","_beforeAllFns","_afterAllFns","_beforeEachFns","_afterEachFns","_timeout","_filename","constructor","some","_isDotOnly","every","_isSkipped","runAsync","config","notifyFn","clock","Object","_recursiveRunAsync","parentMark","parentBeforeEachFns","parentAfterEachFns","options","myMark","beforeResult","runBeforeOrAfterFnsAsync","isSuccess","results","afterResult","testSuiteResult","_testFn","testFn","inheritedMark","runTestAsync","fail","self","itResult","runTestFnAsync","_error","fns","fn","pass","getConfig","Error","timeoutAsync","status"],"mappings":"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"}