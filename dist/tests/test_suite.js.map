{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/test_suite.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\n\nimport * as ensure from \"../util/ensure.js\";\nimport { Clock } from \"../infrastructure/clock.js\";\nimport { TestCaseResult, TestMark, TestMarkValue, TestResult, TestStatus, TestSuiteResult } from \"./test_result.js\";\nimport path from \"node:path\";\n\n// A simple but full-featured test runner. It allows me to get away from Mocha's idiosyncracies and have\n// more control over test execution, while also shielding me from dependency churn.\n\n\nconst DEFAULT_TIMEOUT_IN_MS = 2000;\n\nexport interface TestConfig {\n\t[name: string]: unknown,\n}\n\nexport interface TestOptions {\n\ttimeout?: number,\n\tconfig?: TestConfig,\n\tnotifyFn?: NotifyFn,\n\tclock?: Clock,\n}\n\nexport type NotifyFn = (testResult: TestCaseResult) => void;\n\ninterface Describe {\n\t(optionalName?: string | DescribeFn, describeFn?: DescribeFn): TestSuite,\n\tskip: (optionalName?: string | DescribeFn, descrbeFn?: DescribeFn) => TestSuite,\n\tonly: (optionalName?: string | DescribeFn, describeFn?: DescribeFn) => TestSuite,\n}\ntype DescribeFn = (suiteUtilities: SuiteParameters) => void;\n\ninterface It {\n\t(name: string, itFn?: ItFn): void;\n\tskip: (name: string, itFn?: ItFn) => void,\n\tonly: (name: string, itFn?: ItFn) => void,\n}\ntype ItFn = (testUtilities: TestParameters) => Promise<void> | void;\n\ntype BeforeAfter = (fn: ItFn) => void;\n\ninterface SuiteParameters {\n\tsetTimeout: (newTimeout: Milliseconds) => void,\n}\n\ninterface TestParameters {\n\tgetConfig: <T>(key: string) => T,\n}\n\ntype Milliseconds = number;\n\ninterface RecursiveRunOptions {\n\tname: string[];\n\tfilename?: string;\n\tclock: Clock,\n\tnotifyFn: NotifyFn,\n\ttimeout: Milliseconds,\n\tconfig: TestConfig,\n}\n\ninterface Runnable {\n\t_recursiveRunAsync: (\n\t\tparentMark: TestMarkValue,\n\t\tparentBeforeEachFns: ItFn[],\n\t\tparentAfterEachFns: ItFn[],\n\t\toptions: RecursiveRunOptions,\n\t) => Promise<TestResult> | TestResult;\n\t_isDotOnly: () => boolean,\n\t_isSkipped: (mark: TestMarkValue) => boolean,\n}\n\ninterface TestContext {\n\tdescribe: Describe,\n\tit: It,\n\tbeforeAll: BeforeAfter,\n\tafterAll: BeforeAfter,\n\tbeforeEach: BeforeAfter,\n\tafterEach: BeforeAfter,\n}\n\nconst testContext: TestContext[] = [];\n\n/**\n * A simple but full-featured test runner. It's notable for not using globals.\n */\nexport class TestSuite implements Runnable {\n\n\tprivate _name: string;\n\tprivate _mark: TestMarkValue;\n\tprivate _tests: Runnable[];\n\tprivate _hasDotOnlyChildren: boolean;\n\tprivate _allChildrenSkipped: boolean;\n\tprivate _beforeAllFns: ItFn[];\n\tprivate _afterAllFns: ItFn[];\n\tprivate _beforeEachFns: ItFn[];\n\tprivate _afterEachFns: ItFn[];\n\tprivate _timeout?: Milliseconds;\n\tprivate _filename?: string;\n\n\tstatic get DEFAULT_TIMEOUT_IN_MS() {\n\t\treturn DEFAULT_TIMEOUT_IN_MS;\n\t}\n\n\t/**\n\t * Convert a list of test modules into a test suite. Each module needs to export a test suite by using\n\t * {@link TestSuite.create}.\n\t * @param {string[]} moduleFilenames The filenames of the test modules.\n\t * @returns {TestSuite} The test suite.\n\t */\n\tstatic async fromModulesAsync(moduleFilenames: string[]): Promise<TestSuite> {\n\t\tensure.signature(arguments, [ Array ]);\n\n\t\tconst suites = await Promise.all(moduleFilenames.map(filename => loadModuleAsync(filename)));\n\t\treturn new TestSuite(\"\", TestMark.none, { tests: suites });\n\n\t\tasync function loadModuleAsync(filename: string): Promise<TestSuite> {\n\t\t\tconst errorName = `error when importing ${path.basename(filename)}`;\n\n\t\t\tif (!path.isAbsolute(filename)) {\n\t\t\t\treturn createFailure(errorName, `Test module filenames must use absolute paths: ${filename}`);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst { default: suite } = await import(filename);\n\t\t\t\tif (suite instanceof TestSuite) {\n\t\t\t\t\tsuite._setFilename(filename);\n\t\t\t\t\treturn suite;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn createFailure(errorName, `Test module doesn't export a test suite: ${filename}`, filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(err) {\n\t\t\t\tconst code = (err as { code: string })?.code;\n\t\t\t\tif (code === \"ERR_MODULE_NOT_FOUND\") {\n\t\t\t\t\treturn createFailure(errorName, `Test module not found: ${filename}`, filename);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn createFailure(errorName, err, filename);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction createFailure(name: string, error: unknown, filename?: string) {\n\t\t\treturn new TestSuite(\"\", TestMark.none, { tests: [ new FailureTestCase(name, error, filename) ] });\n\t\t}\n\t}\n\n\t/** @private */\n\tstatic _create(\n\t\tnameOrSuiteFn: string | DescribeFn | undefined,\n\t\tpossibleSuiteFn: DescribeFn | undefined,\n\t\tmark: TestMarkValue,\n\t): TestSuite {\n\t\tensure.signature(arguments, [ [ undefined, String, Function ], [ undefined, Function ], String ]);\n\n\t\tlet name: string;\n\t\tlet suiteFn: DescribeFn | undefined;\n\n\t\tif (nameOrSuiteFn instanceof Function || (nameOrSuiteFn === undefined && possibleSuiteFn === undefined)) {\n\t\t\tname = \"\";\n\t\t\tsuiteFn = nameOrSuiteFn;\n\t\t}\n\t\telse {\n\t\t\tname = nameOrSuiteFn ?? \"\";\n\t\t\tsuiteFn = possibleSuiteFn;\n\t\t}\n\n\t\tif (suiteFn !== undefined) {\n\t\t\treturn this.#runDescribeFunction(suiteFn, name, mark);\n\t\t}\n\t\telse if (mark === TestMark.only) {\n\t\t\treturn new TestSuite(name, mark, {\n\t\t\t\ttests: [ new FailureTestCase(name, \"Test suite is marked '.only', but has no body\") ],\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn new TestSuite(name, TestMark.skip, {});\n\t\t}\n\t}\n\n\tstatic #runDescribeFunction(\n\t\tdescribeFn: DescribeFn,\n\t\tname: string,\n\t\tmark: TestMarkValue,\n\t): TestSuite {\n\t\tconst tests: Runnable[] = [];\n\t\tconst beforeAllFns: ItFn[] = [];\n\t\tconst afterAllFns: ItFn[] = [];\n\t\tconst beforeEachFns: ItFn[] = [];\n\t\tconst afterEachFns: ItFn[] = [];\n\t\tlet timeout: number | undefined;\n\n\t\tconst pushTest = <T extends Runnable>(test: T): T => {\n\t\t\ttests.push(test);\n\t\t\treturn test;\n\t\t};\n\n\t\tconst result: Describe = (optionalName, suiteFn) => this._create(optionalName, suiteFn, TestMark.none);\n\t\tresult.skip = (optionalName, suiteFn) => this._create(optionalName, suiteFn, TestMark.skip);\n\t\tresult.only = (optionalName, suiteFn) => this._create(optionalName, suiteFn, TestMark.only);\n\n\t\tconst describe: Describe = (optionalName, suiteFn) => pushTest(TestSuite._create(optionalName, suiteFn, TestMark.none));\n\t\tdescribe.skip = (optionalName, describeFn) => pushTest(TestSuite._create(optionalName, describeFn, TestMark.skip));\n\t\tdescribe.only = (optionalName, suiteFn) => pushTest(TestSuite._create(optionalName, suiteFn, TestMark.only));\n\n\t\tconst it: It = (name, testCaseFn) => pushTest(new TestCase(name, testCaseFn, TestMark.none));\n\t\tit.skip = (name, testCaseFn) => pushTest(new TestCase(name, testCaseFn, TestMark.skip));\n\t\tit.only = (name, testCaseFn) => pushTest(new TestCase(name, testCaseFn, TestMark.only));\n\n\t\ttestContext.push({\n\t\t\tdescribe,\n\t\t\tit,\n\t\t\tbeforeAll: (fnAsync) => { beforeAllFns.push(fnAsync); },\n\t\t\tafterAll: (fnAsync) => { afterAllFns.push(fnAsync); },\n\t\t\tbeforeEach: (fnAsync) => { beforeEachFns.push(fnAsync); },\n\t\t\tafterEach: (fnAsync) => { afterEachFns.push(fnAsync); },\n\t\t});\n\t\ttry {\n\t\t\tdescribeFn({\n\t\t\t\tsetTimeout: (newTimeoutInMs) => { timeout = newTimeoutInMs; },\n\t\t\t});\n\t\t}\n\t\tfinally {\n\t\t\ttestContext.pop();\n\t\t}\n\n\t\treturn new TestSuite(name, mark, { tests, beforeAllFns, afterAllFns, beforeEachFns, afterEachFns, timeout });\n\t}\n\n\t/** Internal use only. (Use {@link TestSuite.create} or {@link TestSuite.fromModulesAsync} instead.) */\n\tconstructor(name: string, mark: TestMarkValue, {\n\t\ttests = [],\n\t\tbeforeAllFns = [],\n\t\tafterAllFns = [],\n\t\tbeforeEachFns = [],\n\t\tafterEachFns = [],\n\t\ttimeout,\n\t}: {\n\t\ttests?: Runnable[],\n\t\tbeforeAllFns?: ItFn[],\n\t\tafterAllFns?: ItFn[],\n\t\tbeforeEachFns?: ItFn[],\n\t\tafterEachFns?: ItFn[],\n\t\ttimeout?: Milliseconds,\n\t}) {\n\n\t\tthis._name = name;\n\t\tthis._mark = mark;\n\t\tthis._tests = tests;\n\t\tthis._hasDotOnlyChildren = this._tests.some(test => test._isDotOnly());\n\t\tthis._allChildrenSkipped = this._tests.every(test => test._isSkipped(this._mark));\n\t\tthis._beforeAllFns = beforeAllFns;\n\t\tthis._afterAllFns = afterAllFns;\n\t\tthis._beforeEachFns = beforeEachFns;\n\t\tthis._afterEachFns = afterEachFns;\n\t\tthis._timeout = timeout;\n\t}\n\n\t/**\n\t * Run the tests in this suite.\n\t * @param {number} [timeout] Default timeout in milliseconds.\n\t * @param {object} [config={}] Configuration data to provide to tests.\n\t * @param {(result: TestResult) => ()} [notifyFn] A function to call each time a test completes. The `result`\n\t *   parameter describes the result of the test—whether it passed, failed, etc.\n\t * @param {Clock} [clock] The clock to use. Meant for internal use.\n\t * @returns {Promise<TestSuiteResult>} The results of the test suite.\n\t */\n\tasync runAsync({\n\t\ttimeout = DEFAULT_TIMEOUT_IN_MS,\n\t\tconfig = {},\n\t\tnotifyFn = () => {},\n\t\tclock = Clock.create(),\n\t}: TestOptions = {}): Promise<TestSuiteResult> {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\ttimeout: [ undefined, Number ],\n\t\t\tconfig: [ undefined, Object ],\n\t\t\tnotifyFn: [ undefined, Function ],\n\t\t\tclock: [ undefined, Clock ],\n\t\t}]]);\n\n\t\treturn await this._recursiveRunAsync(TestMark.only, [], [], {\n\t\t\tclock,\n\t\t\tconfig,\n\t\t\tnotifyFn,\n\t\t\tname: [],\n\t\t\tfilename: this._filename,\n\t\t\ttimeout: this._timeout ?? timeout ?? DEFAULT_TIMEOUT_IN_MS,\n\t\t});\n\t}\n\n\t/** @private */\n\t_setFilename(filename: string) { this._filename = filename; }\n\n\t/** @private */\n\t_isDotOnly(): boolean {\n\t\treturn this._mark === TestMark.only || this._hasDotOnlyChildren;\n\t}\n\n\t/** @private */\n\t_isSkipped(): boolean {\n\t\treturn this._allChildrenSkipped;\n\t}\n\n\t/** @private */\n\tasync _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tparentBeforeEachFns: ItFn[],\n\t\tparentAfterEachFns: ItFn[],\n\t\toptions: RecursiveRunOptions,\n\t) {\n\t\tconst name = [ ...options.name ];\n\t\tif (this._name !== \"\") name.push(this._name);\n\t\tconst filename = this._filename ?? options.filename;\n\t\tconst timeout = this._timeout ?? options.timeout;\n\t\toptions = { ...options, name, filename, timeout };\n\n\t\tlet myMark = this._mark;\n\t\tif (myMark === TestMark.none) myMark = parentMark;\n\t\tif (myMark === TestMark.only && this._hasDotOnlyChildren) myMark = TestMark.skip;\n\n\t\tconst beforeEachFns = [ ...parentBeforeEachFns, ...this._beforeEachFns ];\n\t\tconst afterEachFns = [ ...this._afterEachFns, ...parentAfterEachFns ];\n\n\t\tif (!this._allChildrenSkipped) {\n\t\t\tconst beforeResult = await runBeforeOrAfterFnsAsync(\n\t\t\t\t[ ...options.name, \"beforeAll()\" ], this._beforeAllFns, TestMark.none, options,\n\t\t\t);\n\t\t\tif (!isSuccess(beforeResult)) return TestResult.suite(options.name, [ beforeResult ], options.filename, this._mark);\n\t\t}\n\n\t\tconst results = [];\n\t\tfor await (const test of this._tests) {\n\t\t\tresults.push(await test._recursiveRunAsync(myMark, beforeEachFns, afterEachFns, options));\n\t\t}\n\n\t\tif (!this._allChildrenSkipped) {\n\t\t\tconst afterResult = await runBeforeOrAfterFnsAsync(\n\t\t\t\t[ ...options.name, \"afterAll()\" ], this._afterAllFns, TestMark.none, options\n\t\t\t);\n\t\t\tif (!isSuccess(afterResult)) results.push(afterResult);\n\t\t}\n\n\t\treturn TestResult.suite(options.name, results, options.filename, this._mark);\n\t}\n\n}\n\n\nclass TestCase implements Runnable {\n\n\tprotected _name: string;\n\tprivate _testFn?: ItFn;\n\tprivate _mark: TestMarkValue;\n\n\tconstructor(name: string, testFn: ItFn | undefined, mark: TestMarkValue) {\n\t\tensure.signature(arguments, [ String, [ undefined, Function ], String ]);\n\n\t\tthis._name = name;\n\t\tthis._testFn = testFn;\n\t\tthis._mark = mark;\n\t}\n\n\t/** @private */\n\t_isDotOnly(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this._mark === TestMark.only;\n\t}\n\n\t/** @private */\n\t_isSkipped(parentMark: TestMarkValue): boolean {\n\t\tconst inheritedMark = this._mark === TestMark.none ? parentMark : this._mark;\n\t\treturn inheritedMark === TestMark.skip;\n\t}\n\n\t/** @private */\n\tasync _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tbeforeEachFns: ItFn[],\n\t\tafterEachFns: ItFn[],\n\t\toptions: RecursiveRunOptions,\n\t): Promise<TestCaseResult> {\n\t\tconst name = [ ...options.name ];\n\t\tname.push(this._name !== \"\" ? this._name : \"(unnamed)\");\n\t\toptions = { ...options, name };\n\n\t\tlet result;\n\t\tif (this._testFn !== undefined) {\n\t\t\tif (!this._isSkipped(parentMark)) {\n\t\t\t\tresult = await runTestAsync(this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = TestResult.skip(name, options.filename, this._mark);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this._mark !== TestMark.only) {\n\t\t\t\tresult = TestResult.skip(name, options.filename, TestMark.skip);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = TestResult.fail(name, \"Test is marked '.only', but it has no body\", options.filename, this._mark);\n\t\t\t}\n\t\t}\n\n\t\toptions.notifyFn(result);\n\t\treturn result;\n\n\t\tasync function runTestAsync(self: TestCase): Promise<TestCaseResult> {\n\t\t\tconst beforeResult = await runBeforeOrAfterFnsAsync(options.name, beforeEachFns, self._mark, options);\n\t\t\tif (!isSuccess(beforeResult)) return beforeResult;\n\n\t\t\tconst itResult = await runTestFnAsync(options.name, self._testFn!, self._mark, options);\n\t\t\tconst afterResult = await runBeforeOrAfterFnsAsync(options.name, afterEachFns, self._mark, options);\n\n\t\t\tif (!isSuccess(itResult)) return itResult;\n\t\t\telse return afterResult;\n\t\t}\n\t}\n}\n\n\nclass FailureTestCase extends TestCase {\n\n\tprivate _filename?: string;\n\tprivate _error: unknown;\n\n\tconstructor(name: string, error: unknown, filename?: string) {\n\t\tsuper(name, undefined, TestMark.none);\n\n\t\tthis._filename = filename;\n\t\tthis._error = error;\n\t}\n\n\toverride async _recursiveRunAsync(\n\t\tparentMark: TestMarkValue,\n\t\tbeforeEachFns: ItFn[],\n\t\tafterEachFns: ItFn[],\n\t\toptions: RecursiveRunOptions,\n\t): Promise<TestCaseResult> {\n\t\tconst result = TestResult.fail([ this._name ], this._error, this._filename);\n\t\toptions.notifyFn(result);\n\t\treturn await result;\n\t}\n\n}\n\n\nasync function runBeforeOrAfterFnsAsync(\n\tname: string[],\n\tfns: ItFn[],\n\tmark: TestMarkValue,\n\toptions: RecursiveRunOptions,\n): Promise<TestCaseResult> {\n\tfor await (const fn of fns) {\n\t\tconst result = await runTestFnAsync(name, fn, mark, options);\n\t\tif (!isSuccess(result)) return result;\n\t}\n\treturn TestResult.pass(name, options.filename, mark);\n}\n\nasync function runTestFnAsync(\n\tname: string[],\n\tfn: ItFn,\n\tmark: TestMarkValue,\n\t{ clock, filename, timeout, config }: RecursiveRunOptions,\n): Promise<TestCaseResult> {\n\tconst getConfig = <T>(name: string) => {\n\t\tif (config[name] === undefined) throw new Error(`No test config found for name '${name}'`);\n\t\treturn config[name] as T;\n\t};\n\n\treturn await clock.timeoutAsync(timeout, async () => {\n\t\ttry {\n\t\t\tawait fn({ getConfig });\n\t\t\treturn TestResult.pass(name, filename, mark);\n\t\t}\n\t\tcatch (err) {\n\t\t\treturn TestResult.fail(name, err, filename, mark);\n\t\t}\n\t}, async () => {\n\t\treturn await TestResult.timeout(name, timeout, filename, mark);\n\t});\n}\n\nfunction isSuccess(result: TestCaseResult) {\n\treturn result.status === TestStatus.pass || result.status === TestStatus.skip;\n}\n\n\nfunction startTest(\n\tnameOrSuiteFn: string | DescribeFn | undefined,\n\tpossibleSuiteFn: DescribeFn | undefined,\n\tmark: TestMarkValue,\n): TestSuite {\n\tensure.that(testContext.length === 0, \"test() is not re-entrant [don't run test() inside of test()]\");\n\n\ttry {\n\t\treturn TestSuite._create(nameOrSuiteFn, possibleSuiteFn, mark);\n\t}\n\tfinally {\n\t\tensure.that(testContext.length === 0, \"test() didn't clear its context; must be an error in ergotest\");\n\t}\n}\n\n/**\n * Creates a top-level test suite. In your test module, call this function and `export default` the result. Add `.skip`\n * to skip this test suite and `.only` to only run this test suite.\n * @param {string} [optionalName] The name of the test suite. You can skip this parameter and pass {@link fn} instead.\n * @param {function} [fn] The body of the test suite. In the body, call {@link describe}, {@link it}, {@link beforeAll},\n *   {@link afterAll}, {@link beforeEach}, and {@link afterEach} to define the tests in the suite. If undefined, this\n *   test suite will be skipped.\n * @returns {TestSuite} The test suite. You’ll typically `export default` the return value rather than using it\n *   directly.\n */\nexport function test(optionalName?: string | DescribeFn, fn?: DescribeFn) {\n\treturn startTest(optionalName, fn, TestMark.none);\n}\n\ntest.skip = function(optionalName?: string | DescribeFn, fn?: DescribeFn) {\n\treturn startTest(optionalName, fn, TestMark.skip);\n};\n\ntest.only = function(optionalName?: string | DescribeFn, fn?: DescribeFn) {\n\treturn startTest(optionalName, fn, TestMark.only);\n};\n\n/**\n * Adds a nested test suite to the current test suite. Must be run inside of a {@link test} or {@link describe}\n * function. Add `.skip` to skip this test suite and `.only` to only run this test suite.\n * @param {string} [optionalName] The name of the test suite. You can skip this parameter and pass {@link fn} instead.\n * @param {function} [fn] The body of the test suite. In the body, call {@link describe}, {@link it}, {@link beforeAll},\n *   {@link afterAll}, {@link beforeEach}, and {@link afterEach} to define the tests in the suite. If undefined, this\n *   test suite will be skipped.\n * @returns {TestSuite} The test suite. You’ll typically ignore the return value.\n */\nexport function describe(optionalName?: string | DescribeFn, fn?: DescribeFn) {\n\tcurrentContext(\"describe\").describe(optionalName, fn);\n}\n\ndescribe.skip = function(optionalName?: string | DescribeFn, fn?: DescribeFn) {\n\tcurrentContext(\"describe\").describe.skip(optionalName, fn);\n};\n\ndescribe.only = function(optionalName?: string | DescribeFn, fn?: DescribeFn) {\n\tcurrentContext(\"describe\").describe.only(optionalName, fn);\n};\n\n/**\n * Adds a test to the current test suite. Must be run inside of a {@link test} or {@link describe} function. Add\n * `.skip` to skip this test and `.only` to only run this test.\n * @param {string} name The name of the test.\n * @param {function} [fnAsync] The body of the test. May be synchronous or asynchronous. If undefined, this test will be\n *   skipped.\n */\nexport function it(name: string, fnAsync?: ItFn) {\n\tcurrentContext(\"it\").it(name, fnAsync);\n}\n\nit.skip = function(name: string, fnAsync?: ItFn) {\n\tcurrentContext(\"it\").it.skip(name, fnAsync);\n};\n\nit.only = function(name: string, fnAsync?: ItFn) {\n\tcurrentContext(\"it\").it.only(name, fnAsync);\n};\n\n/**\n * Adds a function to run before all the tests in the current test suite. Must be run inside of a {@link test} or\n * {@link describe} function.\n * @param {function} [fnAsync] The function to run. May be synchronous or asynchronous.\n */\nexport function beforeAll(fnAsync: ItFn) {\n\tcurrentContext(\"beforeAll\").beforeAll(fnAsync);\n}\n\n/**\n * Adds a function to run after all the tests in the current test suite. Must be run inside of a {@link test} or\n * {@link describe} function.\n * @param {function} [fnAsync] The function to run. May be synchronous or asynchronous.\n */\nexport function afterAll(fnAsync: ItFn) {\n\tcurrentContext(\"afterAll\").afterAll(fnAsync);\n}\n\n/**\n * Adds a function to run bfeore each of the tests in the current test suite. Must be run inside of a {@link test} or\n * {@link describe} function.\n * @param {function} [fnAsync] The function to run. May be synchronous or asynchronous.\n */\nexport function beforeEach(fnAsync: ItFn) {\n\tcurrentContext(\"beforeEach\").beforeEach(fnAsync);\n}\n\n/**\n * Adds a function to run after each of the tests in the current test suite. Must be run inside of a {@link test} or\n * {@link describe} function.\n * @param {function} [fnAsync] The function to run. May be synchronous or asynchronous.\n */\nexport function afterEach(fnAsync: ItFn) {\n\tcurrentContext(\"afterEach\").afterEach(fnAsync);\n}\n\nfunction currentContext(functionName: string) {\n\tensure.that(testContext.length > 0, `${functionName}() must be run inside test()`);\n\n\treturn testContext[testContext.length - 1];\n}"],"names":["ensure","Clock","TestMark","TestResult","TestStatus","path","DEFAULT_TIMEOUT_IN_MS","testContext","TestSuite","_name","_mark","_tests","_hasDotOnlyChildren","_allChildrenSkipped","_beforeAllFns","_afterAllFns","_beforeEachFns","_afterEachFns","_timeout","_filename","fromModulesAsync","moduleFilenames","signature","arguments","Array","suites","Promise","all","map","filename","loadModuleAsync","none","tests","errorName","basename","isAbsolute","createFailure","default","suite","_setFilename","err","code","name","error","FailureTestCase","_create","nameOrSuiteFn","possibleSuiteFn","mark","undefined","String","Function","suiteFn","only","skip","describeFn","beforeAllFns","afterAllFns","beforeEachFns","afterEachFns","timeout","pushTest","test","push","result","optionalName","describe","it","testCaseFn","TestCase","beforeAll","fnAsync","afterAll","beforeEach","afterEach","setTimeout","newTimeoutInMs","pop","constructor","some","_isDotOnly","every","_isSkipped","runAsync","config","notifyFn","clock","create","Number","Object","_recursiveRunAsync","parentMark","parentBeforeEachFns","parentAfterEachFns","options","myMark","beforeResult","runBeforeOrAfterFnsAsync","isSuccess","results","afterResult","_testFn","testFn","inheritedMark","runTestAsync","fail","self","itResult","runTestFnAsync","_error","fns","fn","pass","getConfig","Error","timeoutAsync","status","startTest","that","length","currentContext","functionName"],"mappings":"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"}