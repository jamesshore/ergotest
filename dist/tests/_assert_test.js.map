{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/_assert_test.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC.\n\nimport { test } from \"../tests.js\";\nimport * as assert from \"./assert.js\";\nimport { AssertionError } from \"node:assert\";\n\n/* eslint @typescript-eslint/no-unsafe-function-type: \"off\" */\n// Several functions operate on arbitrary functions.\n\ninterface ObjEquals {\n\tequals(that: unknown): boolean,\n}\n\nexport default test(({ describe }) => {\n\n\tdescribe(\"equal()\", ({ it }) => {\n\n\t\tit(\"passes if actual strictly equals expected\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.equal(\"abc\", \"abc\");\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't strictly equal expected\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.equal(\"1\", 1);\n\t\t\t}, \"should be equal\", \"1\", 1);\n\t\t});\n\n\t\tit(\"passes if all elements of actual strictly equals all elements of expected, recursively\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.equal({\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: 2,\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: 2,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't strictly and deeply equal expected\", () => {\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: \"2\",\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectFail(() => {\n\t\t\t\tassert.equal(actual, expected);\n\t\t\t}, \"should be equal\", actual, expected);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notEqual()\", ({ it }) => {\n\n\t\tit(\"fails if actual strictly equals expected\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notEqual(\"abc\", \"abc\");\n\t\t\t}, \"should not be equal\", \"abc\", \"abc\");\n\t\t});\n\n\t\tit(\"passes if actual doesn't strictly equal expected\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notEqual(\"1\", 1);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if all elements of actual strictly equals all elements of expected, recursively\", () => {\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notEqual(actual, expected);\n\t\t\t}, \"should not be equal\", actual, expected);\n\t\t});\n\n\t\tit(\"passes if actual doesn't strictly and deeply equal expected\", () => {\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: \"2\",\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notEqual(actual, expected);\n\t\t\t});\n\t\t});\n\n\t});\n\n\n\tdescribe(\"identity()\", ({ it }) => {\n\n\t\tit(\"passes if objects have the same reference\", () => {\n\t\t\tconst actual = {};\n\t\t\tconst expected = actual;\n\n\t\t\texpectPass(() => {\n\t\t\t\tassert.identity(actual, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if arrays have the same reference\", () => {\n\t\t\tconst actual: string[] = [];\n\t\t\tconst expected = actual;\n\n\t\t\texpectPass(() => {\n\t\t\t\tassert.identity(actual, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if functions have the same reference\", () => {\n\t\t\tconst actual = () => {};\n\t\t\tconst expected = actual;\n\n\t\t\texpectPass(() => {\n\t\t\t\tassert.identity(actual, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if objects don't have the same reference, even if the contents are identical\", () => {\n\t\t\tconst actual = {};\n\t\t\tconst expected = {};\n\n\t\t\texpectFail(() => {\n\t\t\t\tassert.identity(actual, expected);\n\t\t\t}, \"should have same object reference\", actual, expected);\n\t\t});\n\n\t\tit(\"fails if expected isn't an object\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.identity({}, \"foo\");\n\t\t\t}, \"'expected' is not an object\", {}, \"foo\");\n\t\t});\n\n\t\tit(\"fails if expected is null\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.identity({}, null);\n\t\t\t}, \"'expected' is null\", {}, null);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notIdentity()\", ({ it }) => {\n\n\t\tit(\"fails if objects have the same reference\", () => {\n\t\t\tconst actual = {};\n\t\t\tconst expected = actual;\n\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIdentity(actual, expected);\n\t\t\t}, \"should not have same object reference\", actual, expected);\n\t\t});\n\n\t\tit(\"passes if objects don't have the same reference, even if the contents are identical\", () => {\n\t\t\tconst actual = {};\n\t\t\tconst expected = {};\n\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notIdentity(actual, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if expected isn't an object\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIdentity({}, \"foo\");\n\t\t\t}, \"'expected' is not an object\", {}, \"foo\");\n\t\t});\n\n\t\tit(\"fails if expected is null\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIdentity({}, null);\n\t\t\t}, \"'expected' is null\", {}, null);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"dotEquals()\", ({ it }) => {\n\n\t\tit(\"passes if expected.equals() returns true\", () => {\n\t\t\tconst expected = { equals() { return true; }};\n\t\t\texpectPass(() => {\n\t\t\t\tassert.dotEquals({}, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if expected.equals() returns false\", () => {\n\t\t\tconst expected = { equals() { return false; }};\n\t\t\tconst actual = {};\n\n\t\t\texpectFail(() => {\n\t\t\t\tassert.dotEquals(actual, expected);\n\t\t\t}, \"should be .equals()\", actual, expected);\n\t\t});\n\n\t\tit(\"fails if expected.equals() doesn't exist\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.dotEquals({}, {} as ObjEquals);\n\t\t\t}, \"'expected' does not have equals() method\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"matches()\", ({ it }) => {\n\n\t\tit(\"passes if actual matches regex\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.match(\"abc\", /b/);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't match regex\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.match(\"abc\", /x/);\n\t\t\t}, \"should match regex\", \"abc\", /x/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"matchesGroup()\", ({ it }) => {\n\n\t\tit(\"passes if first group in regex matches expected text\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, \"abc\");\n\t\t\t});\n\t\t});\n\n\t\tit(\"when expected value is null, passes if first group in regex doesn't match\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /x(.*?)x/, null);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if first group doesn't match expected text\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, \"xxx\");\n\t\t\t}, \"regex group: should be equal\", \"abc\", \"xxx\");\n\t\t});\n\n\t\tit(\"fails if group not found\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /x(.*?)x/, \"abc\");\n\t\t\t}, \"regex group expected 'abc', but nothing was found (searched with /x(.*?)x/)\");\n\t\t});\n\n\t\tit(\"when expected value is null, fails if first group in regex matches\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, null);\n\t\t\t}, \"should not have found regex group, but it was 'abc' (searched with /-(.*?)-/)\");\n\t\t});\n\n\t\tit(\"has optional failure message\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-actual-\", /-(.*?)-/, \"expected\", \"my failure message\");\n\t\t\t}, \"my failure message: should be equal\", \"actual\", \"expected\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"includes()\", ({ it }) => {\n\n\t\tit(\"passes if actual includes string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.includes(\"abcdef\", \"bcd\");\n\t\t\t});\n\t\t});\n\n\n\t\tit(\"fails if actual doesn't include string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.includes(\"abcdef\", \"xxx\");\n\t\t\t}, \"actual value should include expected value\", \"abcdef\", \"xxx\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notIncludes()\", ({ it }) => {\n\n\t\tit(\"passes if actual doesn't include string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notIncludes(\"abcdef\", \"xxx\");\n\t\t\t});\n\t\t});\n\n\n\t\tit(\"fails if actual does include string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIncludes(\"abcdef\", \"bcd\");\n\t\t\t}, \"actual value should not include expected value\", \"abcdef\", \"bcd\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"type()\", ({ it }) => {\n\n\t\tit(\"passes if type of actual matches expected type\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.type(1, Number);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if type of actual doesn't match expected type\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.type(1, String);\n\t\t\t}, \"type should match\", 1, \"string\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"exception()\", ({ it }) => {\n\n\t\tit(\"passes if function throws and there's no expectation\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(() => { throw new Error(\"any error\"); });\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches expected string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my error\"); },\n\t\t\t\t\t\"my error\"\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches regex\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my complicated error message\"); },\n\t\t\t\t\t/complicated/\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function doesn't throw\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(() => {});\n\t\t\t}, \"Expected exception\");\n\t\t});\n\n\t\tit(\"fails if function throws and error message doesn't match expected string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my error\"); },\n\t\t\t\t\t\"not my error\"\n\t\t\t\t);\n\t\t\t}, \"should be equal\", \"my error\", \"not my error\");\n\t\t});\n\n\t\tit(\"passes if function throws and error message doesn't match regex\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my complicated error message\"); },\n\t\t\t\t\t/not-found/\n\t\t\t\t);\n\t\t\t}, \"should match regex\", \"my complicated error message\", /not-found/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"exceptionAsync()\", ({ it }) => {\n\n\t\tit(\"passes if function throws and there's no expectation\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(() => Promise.reject(new Error(\"any error\")));\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches expected string\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my error\")),\n\t\t\t\t\t\"my error\"\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches regex\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my complicated error message\")),\n\t\t\t\t\t/complicated/\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function doesn't throw\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(() => Promise.resolve());\n\t\t\t}, \"Expected exception\");\n\t\t});\n\n\t\tit(\"fails if function throws and error message doesn't match expected string\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my error\")),\n\t\t\t\t\t\"not my error\"\n\t\t\t\t);\n\t\t\t}, \"should be equal\", \"my error\", \"not my error\");\n\t\t});\n\n\t\tit(\"passes if function throws and error message doesn't match regex\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my complicated error message\")),\n\t\t\t\t\t/not-found/\n\t\t\t\t);\n\t\t\t}, \"should match regex\", \"my complicated error message\", /not-found/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"noExceptionAsync()\", ({ it }) => {\n\n\t\tit(\"passes if function does not throw exception\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.notErrorAsync(() => Promise.resolve());\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function does throw exception\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.notErrorAsync(() => Promise.reject(new Error(\"my error\")));\n\t\t\t}, \"my error\");\n\t\t});\n\n\t});\n\n});\n\nfunction expectPass(fn: Function) {\n\tfn();\n}\n\nfunction expectFail(fn: Function, expectedFailureMessage: string, actual?: unknown, expected?: unknown) {\n\ttry {\n\t\tfn();\n\t\tassert.fail(\"Expected assertion to fail, but it passed\");\n\t}\n\tcatch (err) {\n\t\tcheckError(err, actual, expected, expectedFailureMessage);\n\t}\n}\n\nasync function expectPassAsync(fnAsync: Function) {\n\tawait fnAsync();\n}\n\nasync function expectFailAsync(fnAsync: Function, expectedFailureMessage: string, actual?: unknown, expected?: unknown) {\n\ttry {\n\t\tawait fnAsync();\n\t\tassert.fail(\"Expected assertion to fail, but it passed\");\n\t}\n\tcatch (err) {\n\t\tcheckError(err, actual, expected, expectedFailureMessage);\n\t}\n}\n\nfunction checkError(err: unknown, actual: unknown, expected: unknown, expectedFailureMessage: string) {\n\tconst typedErr = err as AssertionError;\n\tassert.equal(typedErr.message, expectedFailureMessage, \"failure message\");\n\tcheck(typedErr.expected, expected, \"expected\");\n\tcheck(typedErr.actual, actual, \"actual\");\n\n\tfunction check(actual: unknown, expected: unknown, message: string) {\n\t\tif (actual === undefined) assert.isUndefined(actual, message);\n\t\telse assert.equal(actual, expected, message);\n\t}\n}\n"],"names":["test","assert","describe","it","expectPass","equal","expectFail","a","b","c","actual","expected","notEqual","identity","notIdentity","equals","dotEquals","match","matchesGroup","includes","notIncludes","type","Number","String","error","Error","expectPassAsync","errorAsync","Promise","reject","expectFailAsync","resolve","notErrorAsync","fn","expectedFailureMessage","fail","err","checkError","fnAsync","typedErr","message","check","undefined","isUndefined"],"mappings":"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"}