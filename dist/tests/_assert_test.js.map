{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/_assert_test.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC.\n\nimport { test } from \"../tests.js\";\nimport * as assert from \"./assert.js\";\nimport { AssertionError } from \"node:assert\";\n\n/* eslint @typescript-eslint/no-unsafe-function-type: \"off\" */\n// Several functions operate on arbitrary functions.\n\ninterface ObjEquals {\n\tequals(that: unknown): boolean,\n}\n\nexport default test(({ describe }) => {\n\n\tdescribe(\"equal()\", ({ it }) => {\n\n\t\tit(\"passes if actual strictly equals expected\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.equal(\"abc\", \"abc\");\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't strictly equal expected\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.equal(\"1\", 1);\n\t\t\t}, \"should be equal\", \"1\", 1);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"deepEqual()\", ({ it }) => {\n\n\t\tit(\"passes if all elements of actual strictly equals all elements of expected, recursively\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.deepEqual({\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: 2,\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: 2,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't strictly and deeply equal expected\", () => {\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: \"2\",\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectFail(() => {\n\t\t\t\tassert.deepEqual(actual, expected);\n\t\t\t}, \"expected deep equality\", actual, expected);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"matches()\", ({ it }) => {\n\n\t\tit(\"passes if actual matches regex\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.match(\"abc\", /b/);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't match regex\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.match(\"abc\", /x/);\n\t\t\t}, \"should match regex\", \"abc\", /x/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"matchesGroup()\", ({ it }) => {\n\n\t\tit(\"passes if first group in regex matches expected text\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, \"abc\");\n\t\t\t});\n\t\t});\n\n\t\tit(\"when expected value is null, passes if first group in regex doesn't match\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /x(.*?)x/, null);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if first group doesn't match expected text\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, \"xxx\");\n\t\t\t}, \"regex group: should be equal\", \"abc\", \"xxx\");\n\t\t});\n\n\t\tit(\"fails if group not found\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /x(.*?)x/, \"abc\");\n\t\t\t}, \"regex group expected 'abc', but nothing was found (searched with /x(.*?)x/)\");\n\t\t});\n\n\t\tit(\"when expected value is null, fails if first group in regex matches\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, null);\n\t\t\t}, \"should not have found regex group, but it was 'abc' (searched with /-(.*?)-/)\");\n\t\t});\n\n\t\tit(\"has optional failure message\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-actual-\", /-(.*?)-/, \"expected\", \"my failure message\");\n\t\t\t}, \"my failure message: should be equal\", \"actual\", \"expected\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"includes()\", ({ it }) => {\n\n\t\tit(\"passes if actual includes string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.includes(\"abcdef\", \"bcd\");\n\t\t\t});\n\t\t});\n\n\n\t\tit(\"fails if actual doesn't include string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.includes(\"abcdef\", \"xxx\");\n\t\t\t}, \"actual value should include expected value\", \"abcdef\", \"xxx\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notIncludes()\", ({ it }) => {\n\n\t\tit(\"passes if actual doesn't include string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notIncludes(\"abcdef\", \"xxx\");\n\t\t\t});\n\t\t});\n\n\n\t\tit(\"fails if actual does include string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIncludes(\"abcdef\", \"bcd\");\n\t\t\t}, \"actual value should not include expected value\", \"abcdef\", \"bcd\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"objEqual()\", ({ it }) => {\n\n\t\tit(\"passes if expected.equals() returns true\", () => {\n\t\t\tconst expected = { equals() { return true; }};\n\t\t\texpectPass(() => {\n\t\t\t\tassert.dotEquals({}, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if expected.equals() returns false\", () => {\n\t\t\tconst expected = { equals() { return false; }};\n\t\t\tconst actual = {};\n\n\t\t\texpectFail(() => {\n\t\t\t\tassert.dotEquals(actual, expected);\n\t\t\t}, \"should be equal()\", actual, expected);\n\t\t});\n\n\t\tit(\"fails if expected.equals() doesn't exist\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.dotEquals({}, {} as ObjEquals);\n\t\t\t}, \"'expected' does not have equals() method\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"type()\", ({ it }) => {\n\n\t\tit(\"passes if type of actual matches expected type\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.type(1, Number);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if type of actual doesn't match expected type\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.type(1, String);\n\t\t\t}, \"type should match\", 1, \"string\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"exception()\", ({ it }) => {\n\n\t\tit(\"passes if function throws and there's no expectation\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(() => { throw new Error(\"any error\"); });\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches expected string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my error\"); },\n\t\t\t\t\t\"my error\"\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches regex\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my complicated error message\"); },\n\t\t\t\t\t/complicated/\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function doesn't throw\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(() => {});\n\t\t\t}, \"Expected exception\");\n\t\t});\n\n\t\tit(\"fails if function throws and error message doesn't match expected string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my error\"); },\n\t\t\t\t\t\"not my error\"\n\t\t\t\t);\n\t\t\t}, \"should be equal\", \"my error\", \"not my error\");\n\t\t});\n\n\t\tit(\"passes if function throws and error message doesn't match regex\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my complicated error message\"); },\n\t\t\t\t\t/not-found/\n\t\t\t\t);\n\t\t\t}, \"should match regex\", \"my complicated error message\", /not-found/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"exceptionAsync()\", ({ it }) => {\n\n\t\tit(\"passes if function throws and there's no expectation\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(() => Promise.reject(new Error(\"any error\")));\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches expected string\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my error\")),\n\t\t\t\t\t\"my error\"\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches regex\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my complicated error message\")),\n\t\t\t\t\t/complicated/\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function doesn't throw\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(() => Promise.resolve());\n\t\t\t}, \"Expected exception\");\n\t\t});\n\n\t\tit(\"fails if function throws and error message doesn't match expected string\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my error\")),\n\t\t\t\t\t\"not my error\"\n\t\t\t\t);\n\t\t\t}, \"should be equal\", \"my error\", \"not my error\");\n\t\t});\n\n\t\tit(\"passes if function throws and error message doesn't match regex\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my complicated error message\")),\n\t\t\t\t\t/not-found/\n\t\t\t\t);\n\t\t\t}, \"should match regex\", \"my complicated error message\", /not-found/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"noExceptionAsync()\", ({ it }) => {\n\n\t\tit(\"passes if function does not throw exception\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.noExceptionAsync(() => Promise.resolve());\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function does throw exception\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.noExceptionAsync(() => Promise.reject(new Error(\"my error\")));\n\t\t\t}, \"my error\");\n\t\t});\n\n\t});\n\n});\n\nfunction expectPass(fn: Function) {\n\tfn();\n}\n\nfunction expectFail(fn: Function, expectedFailureMessage: string, actual?: unknown, expected?: unknown) {\n\ttry {\n\t\tfn();\n\t\tassert.fail(\"Expected assertion to fail, but it passed\");\n\t}\n\tcatch (err) {\n\t\tcheckError(err, actual, expected, expectedFailureMessage);\n\t}\n}\n\nasync function expectPassAsync(fnAsync: Function) {\n\tawait fnAsync();\n}\n\nasync function expectFailAsync(fnAsync: Function, expectedFailureMessage: string, actual?: unknown, expected?: unknown) {\n\ttry {\n\t\tawait fnAsync();\n\t\tassert.fail(\"Expected assertion to fail, but it passed\");\n\t}\n\tcatch (err) {\n\t\tcheckError(err, actual, expected, expectedFailureMessage);\n\t}\n}\n\nfunction checkError(err: unknown, actual: unknown, expected: unknown, expectedFailureMessage: string) {\n\tconst typedErr = err as AssertionError;\n\tassert.equal(typedErr.message, expectedFailureMessage, \"failure message\");\n\tcheck(typedErr.expected, expected, \"expected\");\n\tcheck(typedErr.actual, actual, \"actual\");\n\n\tfunction check(actual: unknown, expected: unknown, message: string) {\n\t\tif (actual === undefined) assert.isUndefined(actual, message);\n\t\telse assert.deepEqual(actual, expected, message);\n\t}\n}\n"],"names":["test","assert","describe","it","expectPass","equal","expectFail","deepEqual","a","b","c","actual","expected","match","matchesGroup","includes","notIncludes","equals","dotEquals","type","Number","String","error","Error","expectPassAsync","errorAsync","Promise","reject","expectFailAsync","resolve","noExceptionAsync","fn","expectedFailureMessage","fail","err","checkError","fnAsync","typedErr","message","check","undefined","isUndefined"],"mappings":"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"}