{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/_assert_test.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC.\n\nimport { test } from \"../tests.js\";\nimport * as assert from \"./assert.js\";\nimport { AssertionError } from \"node:assert\";\n\n/* eslint @typescript-eslint/no-unsafe-function-type: \"off\" */\n// Several functions operate on arbitrary functions.\n\ninterface ObjEquals {\n\tequals(that: unknown): boolean,\n}\n\nexport default test(({ describe }) => {\n\n\tdescribe(\"equal()\", ({ it }) => {\n\n\t\tit(\"passes if actual strictly equals expected\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.equal(\"abc\", \"abc\");\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't strictly equal expected\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.equal(\"1\", 1);\n\t\t\t}, \"should be equal\", \"1\", 1);\n\t\t});\n\n\t\tit(\"passes if all elements of actual strictly equals all elements of expected, recursively\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.equal({\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: 2,\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: 2,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't strictly and deeply equal expected\", () => {\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: \"2\",\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectFail(() => {\n\t\t\t\tassert.equal(actual, expected);\n\t\t\t}, \"should be equal\", actual, expected);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notEqual()\", ({ it }) => {\n\n\t\tit(\"fails if actual strictly equals expected\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notEqual(\"abc\", \"abc\");\n\t\t\t}, \"should not be equal\", \"abc\", \"abc\");\n\t\t});\n\n\t\tit(\"passes if actual doesn't strictly equal expected\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notEqual(\"1\", 1);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if all elements of actual strictly equals all elements of expected, recursively\", () => {\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notEqual(actual, expected);\n\t\t\t}, \"should not be equal\", actual, expected);\n\t\t});\n\n\t\tit(\"passes if actual doesn't strictly and deeply equal expected\", () => {\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: \"2\",\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notEqual(actual, expected);\n\t\t\t});\n\t\t});\n\n\t});\n\n\n\tdescribe(\"dotEquals()\", ({ it }) => {\n\n\t\tit(\"passes if expected.equals() returns true\", () => {\n\t\t\tconst expected = { equals() { return true; }};\n\t\t\texpectPass(() => {\n\t\t\t\tassert.dotEquals({}, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if expected.equals() returns false\", () => {\n\t\t\tconst expected = { equals() { return false; }};\n\t\t\tconst actual = {};\n\n\t\t\texpectFail(() => {\n\t\t\t\tassert.dotEquals(actual, expected);\n\t\t\t}, \"should be .equals()\", actual, expected);\n\t\t});\n\n\t\tit(\"fails if expected.equals() doesn't exist\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.dotEquals({}, {} as ObjEquals);\n\t\t\t}, \"'expected' does not have equals() method\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"matches()\", ({ it }) => {\n\n\t\tit(\"passes if actual matches regex\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.match(\"abc\", /b/);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't match regex\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.match(\"abc\", /x/);\n\t\t\t}, \"should match regex\", \"abc\", /x/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"matchesGroup()\", ({ it }) => {\n\n\t\tit(\"passes if first group in regex matches expected text\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, \"abc\");\n\t\t\t});\n\t\t});\n\n\t\tit(\"when expected value is null, passes if first group in regex doesn't match\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /x(.*?)x/, null);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if first group doesn't match expected text\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, \"xxx\");\n\t\t\t}, \"regex group: should be equal\", \"abc\", \"xxx\");\n\t\t});\n\n\t\tit(\"fails if group not found\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /x(.*?)x/, \"abc\");\n\t\t\t}, \"regex group expected 'abc', but nothing was found (searched with /x(.*?)x/)\");\n\t\t});\n\n\t\tit(\"when expected value is null, fails if first group in regex matches\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, null);\n\t\t\t}, \"should not have found regex group, but it was 'abc' (searched with /-(.*?)-/)\");\n\t\t});\n\n\t\tit(\"has optional failure message\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-actual-\", /-(.*?)-/, \"expected\", \"my failure message\");\n\t\t\t}, \"my failure message: should be equal\", \"actual\", \"expected\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"includes()\", ({ it }) => {\n\n\t\tit(\"passes if actual includes string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.includes(\"abcdef\", \"bcd\");\n\t\t\t});\n\t\t});\n\n\n\t\tit(\"fails if actual doesn't include string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.includes(\"abcdef\", \"xxx\");\n\t\t\t}, \"actual value should include expected value\", \"abcdef\", \"xxx\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notIncludes()\", ({ it }) => {\n\n\t\tit(\"passes if actual doesn't include string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notIncludes(\"abcdef\", \"xxx\");\n\t\t\t});\n\t\t});\n\n\n\t\tit(\"fails if actual does include string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIncludes(\"abcdef\", \"bcd\");\n\t\t\t}, \"actual value should not include expected value\", \"abcdef\", \"bcd\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"type()\", ({ it }) => {\n\n\t\tit(\"passes if type of actual matches expected type\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.type(1, Number);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if type of actual doesn't match expected type\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.type(1, String);\n\t\t\t}, \"type should match\", 1, \"string\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"exception()\", ({ it }) => {\n\n\t\tit(\"passes if function throws and there's no expectation\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(() => { throw new Error(\"any error\"); });\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches expected string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my error\"); },\n\t\t\t\t\t\"my error\"\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches regex\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my complicated error message\"); },\n\t\t\t\t\t/complicated/\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function doesn't throw\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(() => {});\n\t\t\t}, \"Expected exception\");\n\t\t});\n\n\t\tit(\"fails if function throws and error message doesn't match expected string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my error\"); },\n\t\t\t\t\t\"not my error\"\n\t\t\t\t);\n\t\t\t}, \"should be equal\", \"my error\", \"not my error\");\n\t\t});\n\n\t\tit(\"passes if function throws and error message doesn't match regex\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my complicated error message\"); },\n\t\t\t\t\t/not-found/\n\t\t\t\t);\n\t\t\t}, \"should match regex\", \"my complicated error message\", /not-found/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"exceptionAsync()\", ({ it }) => {\n\n\t\tit(\"passes if function throws and there's no expectation\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(() => Promise.reject(new Error(\"any error\")));\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches expected string\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my error\")),\n\t\t\t\t\t\"my error\"\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches regex\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my complicated error message\")),\n\t\t\t\t\t/complicated/\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function doesn't throw\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(() => Promise.resolve());\n\t\t\t}, \"Expected exception\");\n\t\t});\n\n\t\tit(\"fails if function throws and error message doesn't match expected string\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my error\")),\n\t\t\t\t\t\"not my error\"\n\t\t\t\t);\n\t\t\t}, \"should be equal\", \"my error\", \"not my error\");\n\t\t});\n\n\t\tit(\"passes if function throws and error message doesn't match regex\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my complicated error message\")),\n\t\t\t\t\t/not-found/\n\t\t\t\t);\n\t\t\t}, \"should match regex\", \"my complicated error message\", /not-found/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"noExceptionAsync()\", ({ it }) => {\n\n\t\tit(\"passes if function does not throw exception\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.notErrorAsync(() => Promise.resolve());\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function does throw exception\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.notErrorAsync(() => Promise.reject(new Error(\"my error\")));\n\t\t\t}, \"my error\");\n\t\t});\n\n\t});\n\n});\n\nfunction expectPass(fn: Function) {\n\tfn();\n}\n\nfunction expectFail(fn: Function, expectedFailureMessage: string, actual?: unknown, expected?: unknown) {\n\ttry {\n\t\tfn();\n\t\tassert.fail(\"Expected assertion to fail, but it passed\");\n\t}\n\tcatch (err) {\n\t\tcheckError(err, actual, expected, expectedFailureMessage);\n\t}\n}\n\nasync function expectPassAsync(fnAsync: Function) {\n\tawait fnAsync();\n}\n\nasync function expectFailAsync(fnAsync: Function, expectedFailureMessage: string, actual?: unknown, expected?: unknown) {\n\ttry {\n\t\tawait fnAsync();\n\t\tassert.fail(\"Expected assertion to fail, but it passed\");\n\t}\n\tcatch (err) {\n\t\tcheckError(err, actual, expected, expectedFailureMessage);\n\t}\n}\n\nfunction checkError(err: unknown, actual: unknown, expected: unknown, expectedFailureMessage: string) {\n\tconst typedErr = err as AssertionError;\n\tassert.equal(typedErr.message, expectedFailureMessage, \"failure message\");\n\tcheck(typedErr.expected, expected, \"expected\");\n\tcheck(typedErr.actual, actual, \"actual\");\n\n\tfunction check(actual: unknown, expected: unknown, message: string) {\n\t\tif (actual === undefined) assert.isUndefined(actual, message);\n\t\telse assert.equal(actual, expected, message);\n\t}\n}\n"],"names":["test","assert","describe","it","expectPass","equal","expectFail","a","b","c","actual","expected","notEqual","equals","dotEquals","match","matchesGroup","includes","notIncludes","type","Number","String","error","Error","expectPassAsync","errorAsync","Promise","reject","expectFailAsync","resolve","notErrorAsync","fn","expectedFailureMessage","fail","err","checkError","fnAsync","typedErr","message","check","undefined","isUndefined"],"mappings":"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"}