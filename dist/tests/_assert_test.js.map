{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/_assert_test.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC.\nimport { describe, it } from \"../tests.js\";\nimport * as assert from \"./assert.js\";\nimport { AssertionError } from \"node:assert\";\n\n/* eslint @typescript-eslint/no-unsafe-function-type: \"off\" */\n// Several functions operate on arbitrary functions.\n\ninterface ObjEquals {\n\tequals(that: unknown): boolean,\n}\n\nexport default describe(() => {\n\n\tdescribe(\"equal()\", () => {\n\n\t\tit(\"passes if actual strictly equals expected\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.equal(\"abc\", \"abc\");\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't strictly equal expected\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.equal(\"1\", 1);\n\t\t\t}, \"should be equal\", \"1\", 1);\n\t\t});\n\n\t\tit(\"passes if all elements of actual strictly equals all elements of expected, recursively\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.equal({\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: 2,\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: 2,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't strictly and deeply equal expected\", () => {\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: \"2\",\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectFail(() => {\n\t\t\t\tassert.equal(actual, expected);\n\t\t\t}, \"should be equal\", actual, expected);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notEqual()\", () => {\n\n\t\tit(\"fails if actual strictly equals expected\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notEqual(\"abc\", \"abc\");\n\t\t\t}, \"should not be equal\", \"abc\", \"abc\");\n\t\t});\n\n\t\tit(\"passes if actual doesn't strictly equal expected\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notEqual(\"1\", 1);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if all elements of actual strictly equals all elements of expected, recursively\", () => {\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notEqual(actual, expected);\n\t\t\t}, \"should not be equal\", actual, expected);\n\t\t});\n\n\t\tit(\"passes if actual doesn't strictly and deeply equal expected\", () => {\n\t\t\tconst actual = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: 2,\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst expected = {\n\t\t\t\ta: 1,\n\t\t\t\tb: {\n\t\t\t\t\tc: \"2\",\n\t\t\t\t},\n\t\t\t};\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notEqual(actual, expected);\n\t\t\t});\n\t\t});\n\n\t});\n\n\n\tdescribe(\"identity()\", () => {\n\n\t\tit(\"passes if objects have the same reference\", () => {\n\t\t\tconst actual = {};\n\t\t\tconst expected = actual;\n\n\t\t\texpectPass(() => {\n\t\t\t\tassert.identity(actual, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if arrays have the same reference\", () => {\n\t\t\tconst actual: string[] = [];\n\t\t\tconst expected = actual;\n\n\t\t\texpectPass(() => {\n\t\t\t\tassert.identity(actual, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if functions have the same reference\", () => {\n\t\t\tconst actual = () => {};\n\t\t\tconst expected = actual;\n\n\t\t\texpectPass(() => {\n\t\t\t\tassert.identity(actual, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if objects don't have the same reference, even if the contents are identical\", () => {\n\t\t\tconst actual = {};\n\t\t\tconst expected = {};\n\n\t\t\texpectFail(() => {\n\t\t\t\tassert.identity(actual, expected);\n\t\t\t}, \"should have same object reference\", actual, expected);\n\t\t});\n\n\t\tit(\"fails if expected isn't an object\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.identity({}, \"foo\");\n\t\t\t}, \"'expected' is not an object\", {}, \"foo\");\n\t\t});\n\n\t\tit(\"fails if expected is null\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.identity({}, null);\n\t\t\t}, \"'expected' is null\", {}, null);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notIdentity()\", () => {\n\n\t\tit(\"fails if objects have the same reference\", () => {\n\t\t\tconst actual = {};\n\t\t\tconst expected = actual;\n\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIdentity(actual, expected);\n\t\t\t}, \"should not have same object reference\", actual, expected);\n\t\t});\n\n\t\tit(\"passes if objects don't have the same reference, even if the contents are identical\", () => {\n\t\t\tconst actual = {};\n\t\t\tconst expected = {};\n\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notIdentity(actual, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if expected isn't an object\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIdentity({}, \"foo\");\n\t\t\t}, \"'expected' is not an object\", {}, \"foo\");\n\t\t});\n\n\t\tit(\"fails if expected is null\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIdentity({}, null);\n\t\t\t}, \"'expected' is null\", {}, null);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"dotEquals()\", () => {\n\n\t\tit(\"passes if expected.equals() returns true\", () => {\n\t\t\tconst expected = { equals() { return true; }};\n\t\t\texpectPass(() => {\n\t\t\t\tassert.dotEquals({}, expected);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if expected.equals() returns false\", () => {\n\t\t\tconst expected = { equals() { return false; }};\n\t\t\tconst actual = {};\n\n\t\t\texpectFail(() => {\n\t\t\t\tassert.dotEquals(actual, expected);\n\t\t\t}, \"should be .equals()\", actual, expected);\n\t\t});\n\n\t\tit(\"fails if expected.equals() doesn't exist\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.dotEquals({}, {} as ObjEquals);\n\t\t\t}, \"'expected' does not have equals() method\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"matches()\", () => {\n\n\t\tit(\"passes if actual matches regex\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.match(\"abc\", /b/);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if actual doesn't match regex\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.match(\"abc\", /x/);\n\t\t\t}, \"should match regex\", \"abc\", /x/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"matchesGroup()\", () => {\n\n\t\tit(\"passes if first group in regex matches expected text\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, \"abc\");\n\t\t\t});\n\t\t});\n\n\t\tit(\"when expected value is null, passes if first group in regex doesn't match\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /x(.*?)x/, null);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if first group doesn't match expected text\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, \"xxx\");\n\t\t\t}, \"regex group: should be equal\", \"abc\", \"xxx\");\n\t\t});\n\n\t\tit(\"fails if group not found\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /x(.*?)x/, \"abc\");\n\t\t\t}, \"regex group expected 'abc', but nothing was found (searched with /x(.*?)x/)\");\n\t\t});\n\n\t\tit(\"when expected value is null, fails if first group in regex matches\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-abc-\", /-(.*?)-/, null);\n\t\t\t}, \"should not have found regex group, but it was 'abc' (searched with /-(.*?)-/)\");\n\t\t});\n\n\t\tit(\"has optional failure message\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.matchesGroup(\"-actual-\", /-(.*?)-/, \"expected\", \"my failure message\");\n\t\t\t}, \"my failure message: should be equal\", \"actual\", \"expected\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"includes()\", () => {\n\n\t\tit(\"passes if actual includes string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.includes(\"abcdef\", \"bcd\");\n\t\t\t});\n\t\t});\n\n\n\t\tit(\"fails if actual doesn't include string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.includes(\"abcdef\", \"xxx\");\n\t\t\t}, \"actual value should include expected value\", \"abcdef\", \"xxx\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"notIncludes()\", () => {\n\n\t\tit(\"passes if actual doesn't include string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.notIncludes(\"abcdef\", \"xxx\");\n\t\t\t});\n\t\t});\n\n\n\t\tit(\"fails if actual does include string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.notIncludes(\"abcdef\", \"bcd\");\n\t\t\t}, \"actual value should not include expected value\", \"abcdef\", \"bcd\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"type()\", () => {\n\n\t\tit(\"passes if type of actual matches expected type\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.type(1, Number);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if type of actual doesn't match expected type\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.type(1, String);\n\t\t\t}, \"type should match\", 1, \"string\");\n\t\t});\n\n\t});\n\n\n\tdescribe(\"exception()\", () => {\n\n\t\tit(\"passes if function throws and there's no expectation\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(() => { throw new Error(\"any error\"); });\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches expected string\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my error\"); },\n\t\t\t\t\t\"my error\"\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches regex\", () => {\n\t\t\texpectPass(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my complicated error message\"); },\n\t\t\t\t\t/complicated/\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function doesn't throw\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(() => {});\n\t\t\t}, \"Expected exception\");\n\t\t});\n\n\t\tit(\"fails if function throws and error message doesn't match expected string\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my error\"); },\n\t\t\t\t\t\"not my error\"\n\t\t\t\t);\n\t\t\t}, \"should be equal\", \"my error\", \"not my error\");\n\t\t});\n\n\t\tit(\"passes if function throws and error message doesn't match regex\", () => {\n\t\t\texpectFail(() => {\n\t\t\t\tassert.error(\n\t\t\t\t\t() => { throw new Error(\"my complicated error message\"); },\n\t\t\t\t\t/not-found/\n\t\t\t\t);\n\t\t\t}, \"should match regex\", \"my complicated error message\", /not-found/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"exceptionAsync()\", () => {\n\n\t\tit(\"passes if function throws and there's no expectation\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(() => Promise.reject(new Error(\"any error\")));\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches expected string\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my error\")),\n\t\t\t\t\t\"my error\"\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"passes if function throws and error message matches regex\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my complicated error message\")),\n\t\t\t\t\t/complicated/\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function doesn't throw\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(() => Promise.resolve());\n\t\t\t}, \"Expected exception\");\n\t\t});\n\n\t\tit(\"fails if function throws and error message doesn't match expected string\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my error\")),\n\t\t\t\t\t\"not my error\"\n\t\t\t\t);\n\t\t\t}, \"should be equal\", \"my error\", \"not my error\");\n\t\t});\n\n\t\tit(\"passes if function throws and error message doesn't match regex\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.errorAsync(\n\t\t\t\t\t() => Promise.reject(new Error(\"my complicated error message\")),\n\t\t\t\t\t/not-found/\n\t\t\t\t);\n\t\t\t}, \"should match regex\", \"my complicated error message\", /not-found/);\n\t\t});\n\n\t});\n\n\n\tdescribe(\"noExceptionAsync()\", () => {\n\n\t\tit(\"passes if function does not throw exception\", async () => {\n\t\t\tawait expectPassAsync(async () => {\n\t\t\t\tawait assert.notErrorAsync(() => Promise.resolve());\n\t\t\t});\n\t\t});\n\n\t\tit(\"fails if function does throw exception\", async () => {\n\t\t\tawait expectFailAsync(async () => {\n\t\t\t\tawait assert.notErrorAsync(() => Promise.reject(new Error(\"my error\")));\n\t\t\t}, \"my error\");\n\t\t});\n\n\t});\n\n});\n\nfunction expectPass(fn: Function) {\n\tfn();\n}\n\nfunction expectFail(fn: Function, expectedFailureMessage: string, actual?: unknown, expected?: unknown) {\n\ttry {\n\t\tfn();\n\t\tassert.fail(\"Expected assertion to fail, but it passed\");\n\t}\n\tcatch (err) {\n\t\tcheckError(err, actual, expected, expectedFailureMessage);\n\t}\n}\n\nasync function expectPassAsync(fnAsync: Function) {\n\tawait fnAsync();\n}\n\nasync function expectFailAsync(fnAsync: Function, expectedFailureMessage: string, actual?: unknown, expected?: unknown) {\n\ttry {\n\t\tawait fnAsync();\n\t\tassert.fail(\"Expected assertion to fail, but it passed\");\n\t}\n\tcatch (err) {\n\t\tcheckError(err, actual, expected, expectedFailureMessage);\n\t}\n}\n\nfunction checkError(err: unknown, actual: unknown, expected: unknown, expectedFailureMessage: string) {\n\tconst typedErr = err as AssertionError;\n\tassert.equal(typedErr.message, expectedFailureMessage, \"failure message\");\n\tcheck(typedErr.expected, expected, \"expected\");\n\tcheck(typedErr.actual, actual, \"actual\");\n\n\tfunction check(actual: unknown, expected: unknown, message: string) {\n\t\tif (actual === undefined) assert.isUndefined(actual, message);\n\t\telse assert.equal(actual, expected, message);\n\t}\n}\n"],"names":["describe","it","assert","expectPass","equal","expectFail","a","b","c","actual","expected","notEqual","identity","notIdentity","equals","dotEquals","match","matchesGroup","includes","notIncludes","type","Number","String","error","Error","expectPassAsync","errorAsync","Promise","reject","expectFailAsync","resolve","notErrorAsync","fn","expectedFailureMessage","fail","err","checkError","fnAsync","typedErr","message","check","undefined","isUndefined"],"mappings":"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"}