{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/_test_runner_test.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\nimport { assert, describe, it, beforeEach } from \"../tests.js\";\nimport { TestRunner } from \"./test_runner.js\";\nimport path from \"node:path\";\nimport { TestSuite } from \"./test_suite.js\";\nimport { TestResult } from \"./test_result.js\";\nimport fs from \"node:fs/promises\";\nimport { Clock } from \"../infrastructure/clock.js\";\nimport { AssertionError } from \"node:assert\";\nimport { write } from \"node:fs\";\nimport { create } from \"node:domain\";\n\nexport default describe(() => {\n\n\tlet TEST_MODULE_PATH: string;\n\n\tbeforeEach(async ({ getConfig }) => {\n\t\tconst testDir = getConfig<string>(\"scratchDir\");\n\n\t\tTEST_MODULE_PATH = `${testDir}/_test_runner_module.js`;\n\t\tawait deleteTempFilesAsync(testDir);\n\t});\n\n\n\tdescribe(\"current process\", () => {\n\n\t\tit(\"runs test modules and passes through config\", async () => {\n\t\t\tconst myConfig = { myConfig: \"my_config\" };\n\t\t\tconst { runner } = await createAsync();\n\n\t\t\tawait writeTestModuleAsync(`throw new Error(getConfig(\"myConfig\"));`);\n\t\t\tconst results = await runner.runInCurrentProcessAsync([ TEST_MODULE_PATH ], { config: myConfig });\n\n\t\t\tassertFailureMessage(results, \"my_config\");\n\t\t});\n\n\t\t// remaining behaviors not tested because of annoyances from them not being isolated\n\n\t});\n\n\n\tdescribe(\"child process\", () => {\n\n\t\tit(\"runs test modules\", async () => {\n\t\t\tconst { runner } = await createAsync();\n\t\t\tawait writeTestModuleAsync(`// passes`);\n\n\t\t\tconst results = await runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\n\t\t\tconst expectedResult = TestResult.suite([], [\n\t\t\t\tTestResult.suite([], [\n\t\t\t\t\tTestResult.pass(\"test\", TEST_MODULE_PATH)\n\t\t\t\t], TEST_MODULE_PATH),\n\t\t\t]);\n\n\t\t\tassert.dotEquals(results, expectedResult);\n\t\t});\n\n\t\tit(\"passes through config\", async () => {\n\t\t\tconst myConfig = { myConfig: \"my_config\" };\n\t\t\tconst { runner } = await createAsync();\n\n\t\t\tawait writeTestModuleAsync(`throw new Error(getConfig(\"myConfig\"));`);\n\t\t\tconst results = await runner.runInChildProcessAsync([ TEST_MODULE_PATH ], { config: myConfig });\n\n\t\t\tassertFailureMessage(results, \"my_config\");\n\t\t});\n\n\t\tit(\"notifies caller of completed tests\", async () => {\n\t\t\tconst { runner } = await createAsync();\n\n\t\t\tconst progress: TestResult[] = [];\n\t\t\tconst notifyFn = (result: TestResult) => progress.push(result);\n\n\t\t\tawait writeTestModuleAsync(`// passes`);\n\t\t\tawait runner.runInChildProcessAsync([ TEST_MODULE_PATH ], { notifyFn });\n\n\t\t\tassert.equal(progress, [\n\t\t\t\tTestResult.pass(\"test\", TEST_MODULE_PATH),\n\t\t\t]);\n\t\t});\n\n\t\tit(\"does not cache test modules from run to run\", async () => {\n\t\t\tconst { runner } = await createAsync();\n\n\t\t\tawait writeTestModuleAsync(`throw new Error(\"module was cached, and shouldn't have been\");`);\n\t\t\tawait runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\n\t\t\tawait writeTestModuleAsync(`throw new Error(\"module was not cached\");`);\n\t\t\tconst results = await runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\n\t\t\tassertFailureMessage(results, \"module was not cached\");\n\t\t});\n\n\t\tit(\"isolates tests\", async () => {\n\t\t\tconst { runner } = await createAsync();\n\n\t\t\tawait writeTestModuleAsync(`global._test_runner_test = true;`);\n\t\t\tawait runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\n\t\t\tawait writeTestModuleAsync(`throw new Error(\"global should be undefined: \" + global._test_runner_test);`);\n\t\t\tconst results = await runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\n\t\t\tassertFailureMessage(results, \"global should be undefined: undefined\");\n\t\t});\n\n\t\tit(\"supports process.chdir(), which isn't allowed in Worker threads\", async () => {\n\t\t\tconst { runner } = await createAsync();\n\n\t\t\tawait writeTestModuleAsync(`\n\t\t\t\tprocess.chdir(\".\");\n\t\t\t\tthrow new Error(\"process.chdir() should execute without error\");\n\t\t\t`);\n\t\t\tconst results = await runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\n\t\t\tassertFailureMessage(results, \"process.chdir() should execute without error\");\n\t\t});\n\n\t\tit(\"handles uncaught promise rejections\", async () => {\n\t\t\tconst { runner } = await createAsync();\n\n\t\t\tawait writeTestModuleAsync(`Promise.reject(new Error(\"my error\"));`);\n\t\t\tconst results = await runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\n\t\t\tassert.equal(results, TestResult.suite([], [\n\t\t\t\tTestResult.fail(\"Unhandled error in tests\", new Error(\"my error\")),\n\t\t\t]));\n\t\t});\n\n\t\tit(\"handles infinite loops\", async () => {\n\t\t\tconst { runner, clock } = await createAsync();\n\n\t\t\tawait writeTestModuleAsync(`while (true);`);\n\t\t\tconst resultsPromise = runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\n\t\t\tawait clock.tickAsync(TestSuite.DEFAULT_TIMEOUT_IN_MS);\n\n\t\t\tassert.equal(await resultsPromise, TestResult.suite([], [\n\t\t\t\tTestResult.fail(\"Test runner watchdog\", \"Detected infinite loop in tests\"),\n\t\t\t]));\n\t\t});\n\t});\n\n\n\tdescribe(\"child process error serialization\", () => {\n\n\t\tit(\"supports generic errors\", async () => {\n\t\t\tawait assertErrorSerializationAsync(`throw new Error(\"my error\")`, new Error(\"my error\"));\n\t\t});\n\n\t\tit(\"supports regexes and similar types\", async () => {\n\t\t\tawait assertErrorSerializationAsync(\n\t\t\t\t`assert.match(\"abc\", /xyz/)`,\n\t\t\t\tnew AssertionError({ message: \"should match regex\", actual: \"abc\", expected: /xyz/}),\n\t\t\t);\n\t\t});\n\n\t\tasync function assertErrorSerializationAsync(testCode: string, expectedError: unknown) {\n\t\t\tconst { runner } = await createAsync();\n\t\t\tawait writeTestModuleAsync(testCode);\n\t\t\tconst result = await runner.runInChildProcessAsync([ TEST_MODULE_PATH ]);\n\t\t\tassert.equal(getErrorResult(result), expectedError);\n\t\t}\n\n\t});\n\n\n\tfunction getErrorResult(result: TestResult) {\n\t\t// @ts-expect-error This line is pretty janky, but that's okay because the tests will fail if stops working\n\t\treturn result.children[0].children[0].error;\n\t}\n\n\tfunction assertFailureMessage(results: TestResult, expectedFailure: string) {\n\t\tassert.equal(getErrorResult(results).message, expectedFailure);\n\t}\n\n\tasync function writeTestModuleAsync(bodySourceCode: string) {\n\t\tawait fs.writeFile(TEST_MODULE_PATH, `\n\t\t\timport { describe, it } from ` + `\"${(path.resolve(import.meta.dirname, \"./test_suite.js\"))}\";\n\t\t\timport * as assert from ` + `\"${(path.resolve(import.meta.dirname, \"./assert.js\"))}\";\n\t\t\t\n\t\t\texport default describe(() => {\n\t\t\t\tit(\"test\", ({ getConfig }) => {\n\t\t\t\t\t${bodySourceCode}\n\t\t\t\t});\n\t\t\t});\n\t\t`);\n\t}\n\n\tasync function deleteTempFilesAsync(testDir: string) {\n\t\tassert.isDefined(testDir);\n\t\tawait fs.rm(testDir, { recursive: true, force: true });\n\t\tawait fs.mkdir(testDir, { recursive: true });\n\t}\n\n});\n\nasync function createAsync({\n\tclock,\n}: { clock?: Clock } = {}) {\n\tclock ??= await Clock.createNullAsync();\n\tconst runner = new TestRunner(clock);\n\n\treturn { runner, clock };\n}"],"names":["assert","describe","it","beforeEach","TestRunner","path","TestSuite","TestResult","fs","Clock","AssertionError","TEST_MODULE_PATH","getConfig","testDir","deleteTempFilesAsync","myConfig","runner","createAsync","writeTestModuleAsync","results","runInCurrentProcessAsync","config","assertFailureMessage","runInChildProcessAsync","expectedResult","suite","pass","dotEquals","progress","notifyFn","result","push","equal","fail","Error","clock","resultsPromise","tickAsync","DEFAULT_TIMEOUT_IN_MS","assertErrorSerializationAsync","message","actual","expected","testCode","expectedError","getErrorResult","children","error","expectedFailure","bodySourceCode","writeFile","resolve","dirname","isDefined","rm","recursive","force","mkdir","createNullAsync"],"mappings":"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"}