{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/tests/test_result.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\n\nimport * as ensure from \"../util/ensure.js\";\nimport util from \"node:util\";\nimport { AssertionError } from \"node:assert\";\nimport { TestMark, TestMarkValue } from \"./test_suite.js\";\nimport { TestRenderer } from \"./test_renderer.js\";\n\nexport const TestStatus = {\n\tpass: \"pass\",\n\tfail: \"fail\",\n\tskip: \"skip\",\n\ttimeout: \"timeout\",\n} as const;\n\nexport type SerializedTestResult = SerializedTestSuiteResult | SerializedTestCaseResult;\n\nexport type TestStatusValue = typeof TestStatus[keyof typeof TestStatus];\n\nexport interface TestCount {\n\tpass: number;\n\tfail: number;\n\tskip: number;\n\ttimeout: number;\n\ttotal: number;\n}\n\nexport interface SerializedTestSuiteResult {\n\ttype: \"TestSuiteResult\";\n\tname: string[];\n\tmark: TestMarkValue;\n\tfilename?: string;\n\tsuite: SerializedTestResult[];\n}\n\nexport interface SerializedTestCaseResult {\n\ttype: \"TestCaseResult\";\n\tname: string[];\n\tmark: TestMarkValue;\n\tfilename?: string;\n\tstatus: TestStatusValue;\n\terror?: unknown;\n\ttimeout?: number;\n}\n\nexport interface SerializedError {\n\ttype: \"Error\" | \"AssertionError\";\n\tmessage: string;\n\tstack?: string;\n\tcustomFields: Record<string, unknown>;\n\tactual?: unknown;\n\texpected?: unknown;\n\toperator?: string;\n}\n\n/**\n * The result of a test run. Can be a single test case or a suite of nested test results.\n */\nexport abstract class TestResult {\n\n\t/**\n\t * Create a TestResult for a suite of tests.\n\t * @param {string|string[]} names The name of the test. Can be a list of names.\n\t * @param {TestResult[]} children The nested results of this suite.\n\t * @param {string} [filename] The file that contained this suite (optional).\n\t * @param {TestMarkValue} [mark] Whether this suite was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestSuiteResult} The result.\n\t */\n\tstatic suite(\n\t\tnames: string | string[],\n\t\tchildren: TestResult[],\n\t\tfilename?: string,\n\t\tmark?: TestMarkValue,\n\t): TestSuiteResult {\n\t\tensure.signature(arguments, [[ String, Array ], Array, [ undefined, String ], [ undefined, String ]]);\n\n\t\treturn new TestSuiteResult(names, children, filename, mark);\n\t}\n\n\t/**\n\t * Create a TestResult for a test that passed.\n\t * @param {string|string[]} names The name of the test. Can be a list of names.\n\t * @param {string} [filename] The file that contained this test (optional).\n\t * @param {TestMarkValue} [mark] Whether this test was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic pass(names: string | string[], filename?: string, mark?: TestMarkValue): TestCaseResult {\n\t\tensure.signature(arguments, [[ String, Array ], [ undefined, String ], [ undefined, String ]]);\n\n\t\treturn new TestCaseResult(names, TestStatus.pass, { filename, mark });\n\t}\n\n\t/**\n\t * Create a TestResult for a test that failed.\n\t * @param {string|string[]} names The name of the test. Can be a list of names.\n\t * @param {unknown} error The error that occurred.\n\t * @param {string} [filename] The file that contained this test (optional).\n\t * @param {TestMarkValue} [mark] Whether this test was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic fail(names: string | string[], error: unknown, filename?: string, mark?: TestMarkValue): TestCaseResult {\n\t\tensure.signature(arguments, [[ String, Array ], ensure.ANY_TYPE, [ undefined, String ], [ undefined, String ]]);\n\n\t\treturn new TestCaseResult(names, TestStatus.fail, { error, filename, mark });\n\t}\n\n\t/**\n\t * Create a TestResult for a test that was skipped.\n\t * @param {string|string[]} names The name of the test. Can be a list of names.\n\t * @param {string} [filename] The file that contained this test (optional).\n\t * @param {TestMarkValue} [mark] Whether this test was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic skip(names: string | string[], filename?: string, mark?: TestMarkValue): TestCaseResult {\n\t\tensure.signature(arguments, [[ String, Array ], [ undefined, String ], [ undefined, String ] ]);\n\n\t\treturn new TestCaseResult(names, TestStatus.skip, { filename, mark });\n\t}\n\n\t/**\n\t * Create a TestResult for a test that timed out.\n\t * @param {string|string[]} names The name of the test. Can be a list of names.\n\t * @param {number} timeout The length of the timeout.\n\t * @param {string} [filename] The file that contained this test (optional).\n\t * @param {TestMarkValue} [mark] Whether this test was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic timeout(names: string | string[], timeout: number, filename?: string, mark?: TestMarkValue): TestCaseResult {\n\t\tensure.signature(arguments, [[ String, Array ], Number, [ undefined, String ], [ undefined, String ] ]);\n\n\t\treturn new TestCaseResult(names, TestStatus.timeout, { timeout, filename, mark });\n\t}\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {objects} serializedTestResult The serialized test result.\n\t * @returns {TestSuiteResult | TestCaseResult} The result object.\n\t * @see TestSuiteResult#serialize\n\t * @see TestCaseResult#serialize\n\t */\n\tstatic deserialize(serializedTestResult: SerializedTestResult): TestResult {\n\t\tensure.signatureMinimum(arguments, [{ type: String }]);\n\n\t\tconst type = serializedTestResult.type;\n\t\tswitch (type) {\n\t\t\tcase \"TestSuiteResult\": return TestSuiteResult.deserialize(serializedTestResult);\n\t\t\tcase \"TestCaseResult\": return TestCaseResult.deserialize(serializedTestResult);\n\t\t\tdefault: ensure.unreachable(`Unrecognized type '${type}' in serialized test result: ${serializedTestResult}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string | undefined} The file that contained the test (or suite), if any.\n\t */\n\tabstract get filename(): string | undefined;\n\n\t/**\n\t * @returns {string []} The name of the test (or suite), and all enclosing suites, with the outermost suite first.\n\t *   Does not include the file name.\n\t */\n\tabstract get name(): string[];\n\n\t/**\n\t * @return { TestMark } Whether the test (or suite) was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tabstract get mark(): TestMarkValue;\n\n\t/**\n\t * @returns {TestCaseResult[]} All the test results, excluding test suites, flattened into a single list.\n\t */\n\tabstract allTests(): TestCaseResult[];\n\n\t/**\n\t * @returns {TestCaseResult[]} All test results, with a mark (.only, etc.) that matches the requested marks,\n\t *   flattened into a single list. This includes suites; although the test results are all in a single list, and are\n\t *   filtered, any suites in the list still have all their children.\n\t */\n\tabstract allMatchingMarks(...marks: TestMarkValue[]): TestResult[];\n\n\t/**\n\t * Convert this result into a bare object later deserialization.\n\t * @returns {SerializedTestSuiteResult} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tabstract serialize(): SerializedTestResult;\n\n\t/**\n\t * Determine if this test result is identical to another test result. To be identical, they must have the same\n\t * results, in the same order, with the same names, filenames, and marks (.only etc.).\n\t * @param {any} that The thing to compare against\n\t * @returns {boolean}\n\t */\n\tabstract equals(that: TestResult): boolean;\n}\n\n/**\n * The result of running a test suite.\n */\nexport class TestSuiteResult extends TestResult {\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {SerializedTestSuiteResult} serializedTestResult The serialized test result.\n\t * @returns {TestSuiteResult} The result object.\n\t * @see TestResult#deserialize\n\t */\n\tstatic deserialize({ name, filename, suite, mark }: SerializedTestSuiteResult): TestSuiteResult {\n\t\tensure.signature(arguments, [{\n\t\t\ttype: String,\n\t\t\tname: Array,\n\t\t\tmark: String,\n\t\t\tfilename: [ undefined, String ],\n\t\t\tsuite: Array,\n\t\t}], [ \"serialized TestSuiteResult\" ]);\n\n\t\tconst deserializedSuite = suite.map(test => TestResult.deserialize(test));\n\t\treturn new TestSuiteResult(name, deserializedSuite, filename, mark);\n\t}\n\n\tprivate readonly _name: string[];\n\tprivate readonly _children: TestResult[];\n\tprivate readonly _filename?: string;\n\tprivate readonly _mark: TestMarkValue;\n\n\t/** Internal use only. (Use {@link TestResult.suite} instead.) */\n\tconstructor(names: string | string[], children: TestResult[], filename?: string, mark?: TestMarkValue) {\n\t\tsuper();\n\t\tthis._name = Array.isArray(names) ? names : [ names ];\n\t\tthis._filename = filename;\n\t\tthis._children = children;\n\t\tthis._mark = mark ?? TestMark.none;\n\t}\n\n\tget name(): string[] {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * @returns {string | undefined} The file that contained the suite, if any.\n\t */\n\tget filename(): string | undefined {\n\t\treturn this._filename;\n\t}\n\n\t/**\n\t * @return { TestMark } Whether the test was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tget mark(): TestMarkValue {\n\t\treturn this._mark;\n\t}\n\n\t/**\n\t * @returns { TestResult[] } This suite's direct children, which can either be test case results or test suite\n\t *   results.\n\t */\n\tget children(): TestResult[] {\n\t\treturn this._children;\n\t}\n\n\t/**\n\t * Convert this suite to a nicely-formatted string. The string describes the tests that have marks (such as .only)\n\t * and provides details about the tests that have failed or timed out. It doesn't provide any details about the tests\n\t * that have passed or been skipped, except for the ones that have marks. After the details, it displays a summary of\n\t * the number of tests that have passed, failed, etc., and the average time required per test.\n\t *\n\t * This is a convenience method. For more control over rendering, use {@link TestRenderer} instead.\n\t *\n\t * @returns The formatted string.\n\t */\n\trender() {\n\t\tconst renderer = TestRenderer.create();\n\t\treturn renderer.renderMarksAsLines(this.allMarkedResults());\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} All the test results, excluding test suites, flattened into a single list.\n\t */\n\tallTests(): TestCaseResult[] {\n\t\tensure.signature(arguments, []);\n\n\t\tconst tests: TestCaseResult[] = [];\n\t\tthis._children.forEach((result: TestResult) => {\n\t\t\tresult.allTests().forEach(subTest => tests.push(subTest));\n\t\t});\n\t\treturn tests;\n\t}\n\n\t/**\n\t * Finds all the test results that match the provided statuses.\n\t * @param {TestStatus[]} statuses The statuses to match.\n\t * @returns {TestCaseResult[]} The test results.\n\t */\n\tallMatchingTests(...statuses: TestStatusValue[]): TestCaseResult[] {\n\t\treturn this.allTests().filter(test => statuses.includes(test.status));\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} All the marked test results (.only, etc.), not including results without marks, but\n\t *   including suites, flattened into a single list. Although the test results are all in a single list, any suites\n\t *   in the list still have all their children.\n\t */\n\tallMarkedResults(): TestResult[] {\n\t\tensure.signature(arguments, []);\n\n\t\tconst allMarks = new Set(Object.values(TestMark));\n\t\tallMarks.delete(TestMark.none);\n\t\treturn this.allMatchingMarks.apply(this, [ ...allMarks ]);\n\t}\n\n\tallMatchingMarks(...marks: TestMarkValue[]): TestResult[] {\n\t\tensureValidMarks(marks);\n\n\t\tconst results = new Set<TestResult>();\n\t\tif (marks.includes(this.mark)) results.add(this);\n\t\tthis._children.forEach((result: TestResult) => {\n\t\t\tif (marks.includes(result.mark)) results.add(result);\n\t\t\tresult.allMatchingMarks.apply(result, marks).forEach(subResult => results.add(subResult));\n\t\t});\n\t\treturn [ ...results ];\n\t}\n\n\t/**\n\t * @returns {string[]} All the test files with 100% passing tests--nothing that was skipped, failed, or timed out.\n\t */\n\tallPassingFiles(): string[] {\n\t\tensure.signature(arguments, []);\n\n\t\tconst allFiles = new Set<string>();\n\t\tconst notPassFiles = new Set<string>();\n\t\tthis.allTests()\n\t\t\t.filter(test => test.filename !== undefined)\n\t\t\t.forEach(test => {\n\t\t\t\tallFiles.add(test.filename!);\n\t\t\t\tif (!test.isPass()) notPassFiles.add(test.filename!);\n\t\t\t});\n\n\t\treturn [ ...differencePolyfill(allFiles, notPassFiles) ];\n\n\t\tfunction differencePolyfill<T>(leftSet: Set<T>, rightSet: Set<T>): Set<T> {\n\t\t\t// Included in Node v22.0; remove this polyfill and replace with left.difference(right) when that enters LTS\n\t\t\treturn new Set([ ...leftSet ].filter(value => !rightSet.has(value)));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {TestCount} A summary count of this suite's results. Includes a count of each type of test result and the\n\t *   total number of tests.\n\t */\n\tcount(): TestCount {\n\t\tconst count = {\n\t\t\t[TestStatus.pass]: 0,\n\t\t\t[TestStatus.fail]: 0,\n\t\t\t[TestStatus.skip]: 0,\n\t\t\t[TestStatus.timeout]: 0,\n\t\t\ttotal: 0,\n\t\t};\n\n\t\tthis.allTests().forEach(test => {\n\t\t\tcount[test.status]++;\n\t\t\tcount.total++;\n\t\t});\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * Convert this suite into a bare object later deserialization.\n\t * @returns {SerializedTestSuiteResult} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tserialize(): SerializedTestSuiteResult {\n\t\treturn {\n\t\t\ttype: \"TestSuiteResult\",\n\t\t\tname: this._name,\n\t\t\tmark: this._mark,\n\t\t\tfilename: this._filename,\n\t\t\tsuite: this._children.map(test => test.serialize()),\n\t\t};\n\t}\n\n\tequals(that: TestResult): boolean {\n\t\tif (!(that instanceof TestSuiteResult)) return false;\n\t\tif (this._mark !== that._mark) return false;\n\n\t\tif (this._children.length !== that._children.length) return false;\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst thisResult = this._children[i]!;\n\t\t\tconst thatResult = that._children[i]!;\n\t\t\tif (!thisResult.equals(thatResult)) return false;\n\t\t}\n\n\t\tconst sameName = util.isDeepStrictEqual(this._name, that._name);\n\t\treturn sameName && this._filename === that._filename;\n\t}\n\n}\n\n\n/**\n * The result of running an individual test.\n */\nexport class TestCaseResult extends TestResult {\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {object} serializedTestResult The serialized test result.\n\t * @returns {TestCaseResult} The result object.\n\t * @see TestResult#deserialize\n\t */\n\tstatic deserialize(serializedResult: SerializedTestCaseResult): TestCaseResult {\n\t\tensure.signature(arguments, [{\n\t\t\ttype: String,\n\t\t\tname: Array,\n\t\t\tmark: String,\n\t\t\tfilename: [ undefined, String ],\n\t\t\tstatus: String,\n\t\t\terror: [ undefined, String, Object ],\n\t\t\ttimeout: [ undefined, Number ],\n\t\t}], [ \"serialized TestCaseResult\" ]);\n\n\t\tconst { name, filename, mark, status, error, timeout } = serializedResult;\n\t\treturn new TestCaseResult(name, status, { error: deserializeError(error), timeout, filename, mark });\n\n\t\tfunction deserializeError(serializedError?: unknown) {\n\t\t\tif (serializedError === undefined || typeof serializedError === \"string\") return serializedError;\n\n\t\t\tconst { type, message, actual, expected, operator, stack, customFields } = serializedError as SerializedError;\n\n\t\t\tlet error;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"AssertionError\":\n\t\t\t\t\terror = new AssertionError({ message, actual, expected, operator });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Error\":\n\t\t\t\t\terror = new Error(message);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tensure.unreachable(`Unrecognized error type '${type} when deserializing TestCaseResult: ${serializedResult}`);\n\t\t\t}\n\t\t\terror.stack = stack;\n\t\t\tObject.entries(customFields).forEach(([ key, value ]) => {\n\t\t\t\t// @ts-expect-error - don't know how to get TypeScript to stop complaining about this\n\t\t\t\terror[key] = value;\n\t\t\t});\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tprivate _name: string[];\n\tprivate _filename?: string;\n\tprivate _status: TestStatusValue;\n\tprivate _mark: TestMarkValue;\n\tprivate _error?: unknown;\n\tprivate _timeout?: number;\n\n\t/** Internal use only. (Use {@link TestResult} factory methods instead.) */\n\tconstructor(\n\t\tnames: string | string[],\n\t\tstatus: TestStatusValue,\n\t\t{ error, timeout, filename, mark }: { error?: unknown, timeout?: number, filename?: string, mark?: TestMarkValue } = {}\n\t) {\n\t\tsuper();\n\t\tthis._name = Array.isArray(names) ? names : [ names ];\n\t\tthis._filename = filename;\n\t\tthis._status = status;\n\t\tthis._mark = mark ?? TestMark.none;\n\t\tthis._error = error;\n\t\tthis._timeout = timeout;\n\t}\n\n\tget filename(): string | undefined {\n\t\treturn this._filename;\n\t}\n\n\tget name(): string[] {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * @returns {TestStatusValue} Whether this test passed, failed, etc.\n\t */\n\tget status(): TestStatusValue {\n\t\treturn this._status;\n\t}\n\n\t/**\n\t * @return { TestMark } Whether the test was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tget mark(): TestMarkValue {\n\t\treturn this._mark;\n\t}\n\n\t/**\n\t * @returns {Error | string} The error that caused this test to fail.\n\t * @throws {Error} Throws an error if this test didn't fail.\n\t */\n\tget error(): unknown {\n\t\tensure.that(this.isFail(), \"Attempted to retrieve error from a test that didn't fail\");\n\t\treturn this._error!;\n\t}\n\n\t/**\n\t * @returns {number} The timeout that this test didn't satisfy. Note that this is not the actual amount of run time\n\t *   of the test.\n\t * @throws {Error} Throws an error if this test didn't time out.\n\t */\n\tget timeout(): number {\n\t\tensure.that(this.isTimeout(), \"Attempted to retrieve timeout from a test that didn't time out\");\n\t\treturn this._timeout!;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test passed.\n\t */\n\tisPass(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this.status === TestStatus.pass;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test failed.\n\t */\n\tisFail(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this.status === TestStatus.fail;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test was skipped.\n\t */\n\tisSkip(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this.status === TestStatus.skip;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test timed out.\n\t */\n\tisTimeout(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this.status === TestStatus.timeout;\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} This test converted into a list of one.\n\t */\n\tallTests(): TestCaseResult[] {\n\t\tensure.signature(arguments, []);\n\t\treturn [ this ];\n\t}\n\n\tallMatchingMarks(...marks: TestMarkValue[]): TestResult[] {\n\t\tensureValidMarks(marks);\n\n\t\tif (marks.includes(this._mark)) return [ this ];\n\t\telse return [];\n\t}\n\n\t/**\n\t * Convert this result into a bare object later deserialization.\n\t * @returns {object} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tserialize(): SerializedTestCaseResult {\n\t\tensure.signature(arguments, []);\n\n\t\treturn {\n\t\t\ttype: \"TestCaseResult\",\n\t\t\tname: this._name,\n\t\t\tmark: this._mark,\n\t\t\tfilename: this._filename,\n\t\t\tstatus: this._status,\n\t\t\terror: serializeError(this._error),\n\t\t\ttimeout: this._timeout,\n\t\t};\n\n\t\tfunction serializeError(error?: unknown) {\n\t\t\tif (!(error instanceof Error)) return error;\n\n\t\t\tconst serialized: SerializedError = {\n\t\t\t\ttype: \"Error\",\n\t\t\t\tmessage: error.message,\n\t\t\t\tstack: error.stack,\n\t\t\t\tcustomFields: { ...error },\n\t\t\t};\n\t\t\tif (error instanceof AssertionError) {\n\t\t\t\tserialized.type = \"AssertionError\";\n\t\t\t\tserialized.actual = error.actual;\n\t\t\t\tserialized.expected = error.expected;\n\t\t\t\tserialized.operator = error.operator;\n\t\t\t}\n\n\t\t\treturn serialized;\n\t\t}\n\t}\n\n\tequals(that: TestResult): boolean {\n\t\tif (!(that instanceof TestCaseResult)) return false;\n\t\tif (this._status !== that._status) return false;\n\t\tif (this._mark !== that._mark) return false;\n\n\t\tconst sameName = util.isDeepStrictEqual(this._name, that._name);\n\t\t// @ts-expect-error - strings are objects, so this._error.message is legit on strings\n\t\tconst sameError = this._error === undefined || this._error.message === that._error.message;\n\n\t\treturn sameName &&\n\t\t\tsameError &&\n\t\t\tthis._timeout === that._timeout &&\n\t\t\tthis.filename === that.filename;\n\t}\n\n}\n\nfunction ensureValidMarks(marks: TestMarkValue[]) {\n\tconst validMarks = Object.values(TestMark);\n\tmarks.forEach((mark, i) => {\n\t\tensure.that(validMarks.includes(mark), `Argument #${i} was '${mark}', which isn't a valid mark`);\n\t});\n}"],"names":["ensure","util","AssertionError","TestMark","TestRenderer","TestStatus","pass","fail","skip","timeout","TestResult","suite","names","children","filename","mark","signature","arguments","String","Array","undefined","TestSuiteResult","TestCaseResult","error","ANY_TYPE","Number","deserialize","serializedTestResult","signatureMinimum","type","unreachable","name","deserializedSuite","map","test","_name","_children","_filename","_mark","constructor","isArray","none","render","renderer","create","renderMarksAsLines","allMarkedResults","allTests","tests","forEach","result","subTest","push","allMatchingTests","statuses","filter","includes","status","allMarks","Set","Object","values","delete","allMatchingMarks","apply","marks","ensureValidMarks","results","add","subResult","allPassingFiles","allFiles","notPassFiles","isPass","differencePolyfill","leftSet","rightSet","value","has","count","total","serialize","equals","that","length","i","thisResult","thatResult","sameName","isDeepStrictEqual","serializedResult","deserializeError","serializedError","message","actual","expected","operator","stack","customFields","Error","entries","key","_status","_error","_timeout","isFail","isTimeout","isSkip","serializeError","serialized","sameError","validMarks"],"mappings":"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"}