{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/infrastructure/clock.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\nimport * as ensure from \"../util/ensure.js\";\n\n// We don't want to import Sinon statically (see comment in nullGlobals below) because that will cause us\n// to have Sinon as a production dependency. However, we can import a Sinon type, because the TypeScript compiler\n// strips type imports out of the compiled code.\nimport type { NodeTimer } from \"@sinonjs/fake-timers\";\n\n\nconst FAKE_START_TIME = 0;\n\nexport interface NulledClockConfiguration {\n\tnow?: number | Date,\n}\n\ntype TimeoutHandle = number;\ntype Runnable<T> = ( () => T ) | ( () => Promise<T> );\n\ninterface ClockGlobals {\n\tDate: typeof Date,\n\tsetTimeout: (fn: (...args: unknown[]) => void, milliseconds: number) => TimeoutHandle,\n\tclearTimeout: (handle: TimeoutHandle) => void,\n\tsetInterval: (fn: (...args: unknown[]) => void, milliseconds: number) => TimeoutHandle,\n\tclearInterval: (handle: TimeoutHandle) => void,\n\ttickAsync: (milliseconds: number) => void,\n\ttickUntilTimersExpireAsync: () => void,\n}\n\n/** System clock. */\nexport class Clock {\n\n\t/**\n\t * Factory method. Wraps the system clock.\n\t * @returns {Clock} the wrapped clock\n\t */\n\tstatic create(): Clock {\n\t\tensure.signature(arguments, []);\n\n\t\treturn new Clock({\n\t\t\tDate,\n\t\t\tsetTimeout,\n\t\t\tclearTimeout,\n\t\t\tsetInterval,\n\t\t\tclearInterval,\n\t\t\ttickAsync() { throw new Error(\"Can't advance the clock because it isn't a null clock\"); },\n\t\t\ttickUntilTimersExpireAsync() { throw new Error(\"Can't advance the clock because it isn't a null clock\"); }\n\t\t});\n\t}\n\n\t/**\n\t * Factory method. Creates a simulated system clock.\n\t * @param [options] overridable options for the simulated clock\n\t * @param {number} [options.now=0] simulated current time\n\t * @returns {Clock} the simulated clock\n\t */\n\tstatic async createNullAsync(options?: NulledClockConfiguration): Promise<Clock> {\n\t\treturn new Clock(await nullGlobalsAsync(options));\n\t}\n\n\tprivate _globals: ClockGlobals;\n\n\t/** Only for use by tests. (Use a factory method instead.) */\n\tconstructor(globals: ClockGlobals) {\n\t\tthis._globals = globals;\n\t}\n\n\t/**\n\t * @returns {number} the current time in milliseconds (equivalent to `Date.now()`)\n\t */\n\tnow(): number {\n\t\tensure.signature(arguments, []);\n\t\treturn this._globals.Date.now();\n\t}\n\n\t/**\n\t * Wait for a certain amount of time has passed. Equivalent to `setTimeout()`, which is not guaranteed to be exact.\n\t * Special note for nulled clocks: time doesn't pass automatically for nulled clocks, so this method won't return\n\t * unless one of the tick methods is called.\n\t * @param {number} milliseconds the approximate number of milliseconds to wait\n\t */\n\tasync waitAsync(milliseconds: number): Promise<void> {\n\t\tensure.signature(arguments, [ Number ]);\n\t\tawait new Promise((resolve) => {\n\t\t\tthis._globals.setTimeout(resolve, milliseconds);\n\t\t});\n\t}\n\n\t/**\n\t * Run a function approximately every N milliseconds. Equivalent to `setInterval()`, which is not guaranteed to be\n\t * exact. Special note for nulled clocks: time doesn't pass automatically for nulled clocks, so this method won't\n\t * return unless one of the tick methods is called.\n\t * @param {number} milliseconds\n\t * @param {() => void} fn The function to run.\n\t * @returns {() => void} A function that will cancel the repetition (equivalent to `clearInterval()`).\n\t */\n\trepeat(milliseconds: number, fn: () => void): () => void {\n\t\tensure.signature(arguments, [ Number, Function ]);\n\n\t\tconst handle = this._globals.setInterval(fn, milliseconds);\n\t\treturn () => this._globals.clearInterval(handle);\n\t}\n\n\t/**\n\t * The number of milliseconds that have elapsed since a particular time.\n\t * @param { Date | number } startAsDateOrMilliseconds\n\t * @returns {number} The elapsed milliseconds.\n\t */\n\tmillisecondsSince(startAsDateOrMilliseconds: number | Date): number {\n\t\tensure.signature(arguments, [[ Number, Date ]]);\n\t\treturn this.now() - startAsDateOrMilliseconds.valueOf();\n\t}\n\n\t/**\n\t * The number of milliseconds until a particular time.\n\t * @param { Date | number } endAsDateOrMilliseconds\n\t * @returns {number} The milliseconds remaining.\n\t */\n\tmillisecondsUntil(endAsDateOrMilliseconds: number | Date): number {\n\t\tensure.signature(arguments, [[ Number, Date ]]);\n\t\treturn endAsDateOrMilliseconds.valueOf() - this.now();\n\t}\n\n\t/**\n\t * A \"dead man's switch.\" Calls `timeoutFn` if `aliveFn` hasn't been called in the last N milliseconds. Special note\n\t * for nulled clocks: time doesn't pass automatically for nulled clocks, so this method won't time out unless one of\n\t * the tick methods is called.\n\t * @param {number} milliseconds The number of milliseconds to wait before calling `timeoutFn`.\n\t * @param {() => void} timeoutFn The function to call if aliveFn() isn't called after `milliseconds`.\n\t * @returns {{aliveFn: () => void, cancelFn: () => void}} Call aliveFn() to reset the timeout. Call cancelFn() to\n\t *   stop the timeout.\n\t */\n\tkeepAlive(milliseconds: number, timeoutFn: () => void): { aliveFn: () => void, cancelFn: () => void } {\n\t\tensure.signature(arguments, [ Number, Function ]);\n\n\t\tlet cancelled = false;\n\t\tlet handle : TimeoutHandle;\n\n\t\tstartTimer(this);\n\n\t\treturn {\n\t\t\taliveFn: () => {\n\t\t\t\tif (cancelled) return;\n\t\t\t\tthis._globals.clearTimeout(handle);\n\t\t\t\tstartTimer(this);\n\t\t\t},\n\n\t\t\tcancelFn: () => {\n\t\t\t\tcancelled = true;\n\t\t\t\tthis._globals.clearTimeout(handle);\n\t\t\t},\n\t\t};\n\n\t\tfunction startTimer(self: Clock): void {\n\t\t\thandle = self._globals.setTimeout(timeoutFn, milliseconds);\n\t\t}\n\t}\n\n\t/**\n\t * Wait for a promise to resolve and return its value. If it hasn't completed in a certain amount of time, run a\n\t * timeout function and return its value instead. Note that this DOES NOT CANCEL the original promise, which will\n\t * still run to completion, although its return value will be discarded. (Promises cannot be cancelled.) Any\n\t * cancellation mechanism you want to use must be programmed into the promise and timeout function.\n\t * @template T\n\t * @param {number} milliseconds the approximate number of milliseconds to wait\n\t * @param {() => T | Promise<T>} fnAsync the promise to wait for\n\t * @param {() => T | Promise<T>} timeoutFnAsync the function to run when the time is up\n\t * @returns {Promise<T>} the promise's return value (if the promise resolves in time) or the timeout function's\n\t *   return value (if it doesn't)\n\t */\n\tasync timeoutAsync<T>(milliseconds: number, fnAsync: Runnable<T>, timeoutFnAsync: Runnable<T>): Promise<T> {\n\t\tensure.signature(arguments, [ Number, Function, Function ]);\n\n\t\treturn await new Promise((resolve, reject) => {\n\t\t\tconst timeoutToken = this._globals.setTimeout(() => {\n\t\t\t\tPromise.resolve(timeoutFnAsync()).then(resolve).catch(reject);\n\t\t\t}, milliseconds);\n\n\t\t\tPromise.resolve(fnAsync())\n\t\t\t\t.then(resolve)\n\t\t\t\t.catch(reject)\n\t\t\t\t.finally(() => this._globals.clearTimeout(timeoutToken));\n\t\t});\n\t}\n\n\t/**\n\t * Advance a nulled clock forward in time. Throws an exception if the clock isn't nulled. (For\n\t * non-nulled clocks, use waitAsync() instead.)\n\t * @param {number} milliseconds the number of milliseconds to advance the clock\n\t */\n\tasync tickAsync(milliseconds: number): Promise<void> {\n\t\tensure.signature(arguments, [ Number ]);\n\t\tawait this._globals.tickAsync(milliseconds);\n\t}\n\n\t/**\n\t * Advance a nulled clock forward in time until all timers expire. Throws an exception if the\n\t * clock isn't nulled.\n\t */\n\tasync tickUntilTimersExpireAsync(): Promise<void> {\n\t\tensure.signature(arguments, []);\n\t\tawait this._globals.tickUntilTimersExpireAsync();\n\t}\n\n}\n\n\n\nasync function nullGlobalsAsync({\n\tnow = FAKE_START_TIME,\n}: NulledClockConfiguration = {}) {\n\tensure.signature(arguments, [[ undefined, {\n\t\tnow: [ undefined, Number, Date ],\n\t}]]);\n\n\t// Because this is production code, using a static import would require us to include Sinon as a production\n\t// dependency. If we donâ€™t, the code will fail to load when it encounters the static import.\n\t//\n\t// But we only use this code in our tests, so using a dynamic import allows us to make it work in development,\n\t// but not have Sinon in our production release.\n\tconst FakeTimers = await import(\"@sinonjs/fake-timers\");\n\tconst fake = FakeTimers.createClock(now);\n\n\treturn {\n\t\tDate: fake.Date,\n\n\t\tasync tickAsync(milliseconds: number): Promise<void> {\n\t\t\tawait fake.tickAsync(milliseconds);\n\t\t},\n\n\t\tasync tickUntilTimersExpireAsync(): Promise<void> {\n\t\t\tawait fake.runAllAsync();\n\t\t},\n\n\t\tsetTimeout(fn: () => void, milliseconds: number): TimeoutHandle {\n\t\t\treturn fake.setTimeout(fn, milliseconds) as TimeoutHandle;\n\t\t},\n\n\t\tclearTimeout(handle: TimeoutHandle): void {\n\t\t\treturn fake.clearTimeout(handle as number & NodeTimer);\n\t\t},\n\n\t\tsetInterval(fn: () => void, milliseconds: number): TimeoutHandle {\n\t\t\treturn fake.setInterval(fn, milliseconds) as TimeoutHandle;\n\t\t},\n\n\t\tclearInterval(handle: TimeoutHandle): void {\n\t\t\treturn fake.clearInterval(handle as number & NodeTimer);\n\t\t},\n\t};\n\n}\n"],"names":["ensure","FAKE_START_TIME","Clock","create","signature","arguments","Date","setTimeout","clearTimeout","setInterval","clearInterval","tickAsync","Error","tickUntilTimersExpireAsync","createNullAsync","options","nullGlobalsAsync","_globals","constructor","globals","now","waitAsync","milliseconds","Number","Promise","resolve","repeat","fn","Function","handle","millisecondsSince","startAsDateOrMilliseconds","valueOf","millisecondsUntil","endAsDateOrMilliseconds","keepAlive","timeoutFn","cancelled","startTimer","aliveFn","cancelFn","self","timeoutAsync","fnAsync","timeoutFnAsync","reject","timeoutToken","then","catch","finally","undefined","FakeTimers","fake","createClock","runAllAsync"],"mappings":"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"}