{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/infrastructure/colors.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\n\ntype Style = \"bold\" | \"dim\" | \"underline\" | \"blink\" | \"inverse\";\n\nconst COLOR_STYLES = {\n\tbold: \"1;\",\n\tdim: \"2;\",\n\tunderline: \"4;\",\n\tblink: \"5;\",\n\tinverse: \"7;\",\n};\n\n/**\n * Call these functions to wrap a string in ANSI color codes. Add `.bold`, `.dim`, `.underline`, `.blink`, or `.inverse` to the function to add the corresponding ANSI codes. String as many effects together as you like. (Note that not all terminals support all effects.)\n */\nexport const Colors = {\n\t// this brute-force approach works better with IDE code completion than building the object at run-time.\n\tblack: colorFn(30),\n\tred: colorFn(31),\n\tgreen: colorFn(32),\n\tyellow: colorFn(33),\n\tblue: colorFn(34),\n\tpurple: colorFn(35),\n\tcyan: colorFn(36),\n\twhite: colorFn(37),\n\tbrightBlack: colorFn(90),\n\tbrightRed: colorFn(91),\n\tbrightGreen: colorFn(92),\n\tbrightYellow: colorFn(93),\n\tbrightBlue: colorFn(94),\n\tbrightPurple: colorFn(95),\n\tbrightCyan: colorFn(96),\n\tbrightWhite: colorFn(97),\n};\n\nexport interface ColorFn {\n\t(name: string): string;\n\tbold: ColorFn;\n\tdim: ColorFn;\n\tunderline: ColorFn;\n\tblink: ColorFn;\n\tinverse: ColorFn;\n}\n\nfunction colorFn(color: number): ColorFn {\n\tconst fn = encodeFn(\"\", color);\n\tcombinatorialize(fn, \"\", color, COLOR_STYLES);\n\treturn fn;\n\n\tfunction encodeFn(style: string, color: number) {\n\t\treturn ((text: string) => `\\u001b[${style}${color}m${text}\\u001b[0m`) as ColorFn;\n\t}\n\n\tfunction combinatorialize(fn: ColorFn, baseStyle: string, color: number, styles: Record<Style, string>) {\n\t\t// adds .bold, .dim, etc. to fn, and does so recursively.\n\t\tconst styleNames = Object.keys(styles) as Style[];\n\t\tstyleNames.forEach((styleKey) => {\n\t\t\tconst myStyle = baseStyle + styles[styleKey];\n\t\t\tfn[styleKey] = encodeFn(myStyle, color);\n\n\t\t\tconst remainingStyles = { ...styles };\n\t\t\tdelete remainingStyles[styleKey];\n\t\t\tcombinatorialize(fn[styleKey], myStyle, color, remainingStyles);\n\t\t});\n\t}\n}\n"],"names":["COLOR_STYLES","bold","dim","underline","blink","inverse","Colors","black","colorFn","red","green","yellow","blue","purple","cyan","white","brightBlack","brightRed","brightGreen","brightYellow","brightBlue","brightPurple","brightCyan","brightWhite","color","fn","encodeFn","combinatorialize","style","text","baseStyle","styles","styleNames","Object","keys","forEach","styleKey","myStyle","remainingStyles"],"mappings":"AAAA,iFAAiF;AAIjF,MAAMA,eAAe;IACpBC,MAAM;IACNC,KAAK;IACLC,WAAW;IACXC,OAAO;IACPC,SAAS;AACV;AAEA;;CAEC,GACD,OAAO,MAAMC,SAAS;IACrB,wGAAwG;IACxGC,OAAOC,QAAQ;IACfC,KAAKD,QAAQ;IACbE,OAAOF,QAAQ;IACfG,QAAQH,QAAQ;IAChBI,MAAMJ,QAAQ;IACdK,QAAQL,QAAQ;IAChBM,MAAMN,QAAQ;IACdO,OAAOP,QAAQ;IACfQ,aAAaR,QAAQ;IACrBS,WAAWT,QAAQ;IACnBU,aAAaV,QAAQ;IACrBW,cAAcX,QAAQ;IACtBY,YAAYZ,QAAQ;IACpBa,cAAcb,QAAQ;IACtBc,YAAYd,QAAQ;IACpBe,aAAaf,QAAQ;AACtB,EAAE;AAWF,SAASA,QAAQgB,KAAa;IAC7B,MAAMC,KAAKC,SAAS,IAAIF;IACxBG,iBAAiBF,IAAI,IAAID,OAAOxB;IAChC,OAAOyB;IAEP,SAASC,SAASE,KAAa,EAAEJ,KAAa;QAC7C,OAAQ,CAACK,OAAiB,CAAC,OAAO,EAAED,QAAQJ,MAAM,CAAC,EAAEK,KAAK,SAAS,CAAC;IACrE;IAEA,SAASF,iBAAiBF,EAAW,EAAEK,SAAiB,EAAEN,KAAa,EAAEO,MAA6B;QACrG,yDAAyD;QACzD,MAAMC,aAAaC,OAAOC,IAAI,CAACH;QAC/BC,WAAWG,OAAO,CAAC,CAACC;YACnB,MAAMC,UAAUP,YAAYC,MAAM,CAACK,SAAS;YAC5CX,EAAE,CAACW,SAAS,GAAGV,SAASW,SAASb;YAEjC,MAAMc,kBAAkB;gBAAE,GAAGP,MAAM;YAAC;YACpC,OAAOO,eAAe,CAACF,SAAS;YAChCT,iBAAiBF,EAAE,CAACW,SAAS,EAAEC,SAASb,OAAOc;QAChD;IACD;AACD"}