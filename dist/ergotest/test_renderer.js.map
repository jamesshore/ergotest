{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/ergotest/test_renderer.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\n\nimport * as ensure from \"../util/ensure.js\";\nimport { TestCaseResult, TestMark, TestMarkValue, TestResult, TestStatus, TestSuiteResult } from \"./test_result.js\";\nimport { ColorFn, Colors } from \"../infrastructure/colors.js\";\nimport path from \"node:path\";\nimport { AssertionError } from \"node:assert\";\nimport util from \"node:util\";\nimport { SourceMap } from \"../infrastructure/source_map.js\";\n\nconst headerColor = Colors.brightWhite.bold;\nconst highlightColor = Colors.brightWhite;\nconst stackHighlightColor = Colors.brightYellow.bold;\nconst errorMessageColor = Colors.brightRed;\nconst timeoutMessageColor = Colors.purple;\nconst expectedColor = Colors.green;\nconst actualColor = Colors.brightRed;\nconst diffColor = Colors.brightYellow.bold;\nconst summaryColor = Colors.brightWhite.dim;\n\n/**\n * Converts an error into a detailed description of a test failure. Intended to be used with {@link TestOptions}\n * rather than called directly.\n * @param {string[]} name The names of the test\n * @param {unknown} error The error that occurred\n * @param {TestMarkValue} mark Whether the test was marked '.skip', '.only', etc.\n * @param {string} [filename] The file that contained the test, if known\n * @return The description\n */\nexport function renderError(name: string[], error: unknown, mark: TestMarkValue, filename?: string) {\n\tensure.signature(arguments, [ Array, ensure.ANY_TYPE, String, [ undefined, String ] ]);\n\n\tconst finalName = normalizeName(name).pop();\n\n\tlet renderedError;\n\tif (error instanceof Error && error?.stack !== undefined) {\n\t\trenderedError = renderStack(error, filename);\n\t\tif (error.message !== undefined && error.message !== \"\") {\n\t\t\trenderedError +=\n\t\t\t\t\"\\n\\n\" +\n\t\t\t\thighlightColor(`${finalName} »\\n`) +\n\t\t\t\terrorMessageColor(`${error.message}`);\n\t\t}\n\t}\n\telse if (typeof error === \"string\") {\n\t\trenderedError = errorMessageColor(error);\n\t}\n\telse {\n\t\trenderedError = errorMessageColor(util.inspect(error));\n\t}\n\n\tconst diff = (error instanceof AssertionError) ?\n\t\t\"\\n\\n\" + renderDiff(error) :\n\t\t\"\";\n\n\treturn `${renderedError}${diff}`;\n}\n\n/**\n * Provides an error's stack trace, or \"\" if there wasn't one. If `filename` is provided, the stack frames that\n * correspond to the filename will be highlighted.\n * @param {unknown} error The error\n * @param {string} [filename] The filename to highlight\n * @param [sourceMap] Internal use only\n * @returns {string} The stack trace for the test, or \"\" if there wasn't one.\n */\nexport function renderStack(error: Error, filename?: string, sourceMap = SourceMap.create()): string {\n\tensure.signature(arguments, [ ensure.ANY_TYPE, [ undefined, String ], [ undefined, SourceMap ] ]);\n\n\tconst stack = error instanceof AssertionError ?\n\t\terror.stack ?? \"\" :\n\t\tutil.inspect(error);\n\n\tif (filename === undefined) return stack;\n\n\tlet filenamesToHighlight = sourceMap.getOriginalFilenames(filename);\n\tif (filenamesToHighlight.length === 0) filenamesToHighlight = [ filename ];\n\n\tconst lines = stack.split(\"\\n\");\n\tconst highlightedLines = lines.map(line => {\n\t\tconst shouldHighlight = filenamesToHighlight.some(filename => line.includes(filename));\n\n\t\tif (!shouldHighlight) return line;\n\n\t\tline = line.replace(/    at/, \"--> at\");\t// this code is vulnerable to changes in Node.js rendering\n\t\treturn stackHighlightColor(line);\n\t});\n\treturn highlightedLines.join(\"\\n\");\n}\n\n/**\n *\n * @returns {string} A comparison of expected and actual values, or \"\" if there weren't any.\n */\nexport function renderDiff(error: AssertionError): string {\n\tensure.signature(arguments, [ AssertionError ]);\n\n\tif (error.expected === undefined && error.actual === undefined) return \"\";\n\tif (error.expected === null && error.actual === null) return \"\";\n\n\tconst expected = util.inspect(error.expected, { depth: Infinity }).split(\"\\n\");\n\tconst actual = util.inspect(error.actual, { depth: Infinity }).split(\"\\n\");\n\tif (expected.length > 1 || actual.length > 1) {\n\t\tfor (let i = 0; i < Math.max(expected.length, actual.length); i++) {\n\t\t\tconst expectedLine = expected[i];\n\t\t\tconst actualLine = actual[i];\n\n\t\t\tif (expectedLine !== actualLine) {\n\t\t\t\tif (expected[i] !== undefined) expected[i] = diffColor(expected[i]!);\n\t\t\t\tif (actual[i] !== undefined) actual[i] = diffColor(actual[i]!);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\" +\n\t\texpectedColor(\"expected: \") + expected.join(\"\\n\") + \"\\n\" +\n\t\tactualColor(\"actual:   \") + actual.join(\"\\n\");\n}\n\nexport class TestRenderer {\n\n\tstatic create() {\n\t\treturn new TestRenderer();\n\t}\n\n\t// can't use a normal constant due to a circular dependency between TestResult and TestRenderer\n\tstatic get #PROGRESS_RENDERING() {\n\t\treturn {\n\t\t\t[TestStatus.pass]: \".\",\n\t\t\t[TestStatus.fail]: Colors.brightRed.inverse(\"X\"),\n\t\t\t[TestStatus.skip]: Colors.cyan.dim(\"_\"),\n\t\t\t[TestStatus.timeout]: Colors.purple.inverse(\"!\"),\n\t\t};\n\t}\n\n\t// can't use a normal constant due to a circular dependency between TestResult and TestRenderer\n\tstatic get #DESCRIPTION_RENDERING() {\n\t\treturn {\n\t\t\t[TestStatus.pass]: Colors.green(\"passed\"),\n\t\t\t[TestStatus.fail]: Colors.brightRed(\"failed\"),\n\t\t\t[TestStatus.skip]: Colors.brightCyan(\"skipped\"),\n\t\t\t[TestStatus.timeout]: Colors.brightPurple(\"timeout\"),\n\t\t};\n\t}\n\n\t/**\n\t * @param {TestSuiteResult} testSuiteResult The test suite to render.\n\t * @param {number} [elapsedMs] The total time required to run the test suite, in milliseconds.\n\t * @returns {string} A summary of the results of a test suite, including the average time required per test if\n\t *   `elapsedMs` is defined.\n\t */\n\trenderSummary(testSuiteResult: TestSuiteResult, elapsedMs?: number): string {\n\t\tensure.signature(arguments, [ TestSuiteResult, [ undefined, Number ]]);\n\n\t\tconst { total, pass, fail, timeout, skip } = testSuiteResult.count();\n\n\t\tconst renders = [\n\t\t\trenderCount(fail, \"failed\", Colors.brightRed),\n\t\t\trenderCount(timeout, \"timed out\", Colors.purple),\n\t\t\trenderCount(skip, \"skipped\", Colors.cyan),\n\t\t\trenderCount(pass, \"passed\", Colors.green),\n\t\t\trenderMsEach(elapsedMs, total, skip),\n\t\t].filter(render => render !== \"\");\n\n\t\treturn summaryColor(\"(\") + renders.join(summaryColor(\"; \")) + summaryColor(\")\");\n\n\t\tfunction renderCount(number: number, description: string, color: ColorFn): string {\n\t\t\tif (number === 0) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn color(`${number} ${description}`);\n\t\t\t}\n\t\t}\n\n\t\tfunction renderMsEach(elapsedMs: number | undefined, total: number, skip: number): string {\n\t\t\tif (total - skip === 0) return summaryColor(\"none ran\");\n\t\t\tif (elapsedMs === undefined) return \"\";\n\n\t\t\tconst msEach = (elapsedMs / (total - skip)).toFixed(1);\n\t\t\treturn summaryColor(`${msEach}ms avg.`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string} A single character for each test: a dot for passed, a red X for failed, etc.\n\t */\n\trenderAsCharacters(testCaseResults: TestCaseResult | TestCaseResult[]): string {\n\t\tensure.signature(arguments, [[ TestCaseResult, Array ]]);\n\n\t\treturn this.#renderMultipleResults(testCaseResults, \"\", TestCaseResult, (testResult: TestCaseResult) => {\n\t\t\treturn (TestRenderer.#PROGRESS_RENDERING)[testResult.status];\n\t\t});\n\t}\n\n\t/**\n\t * @returns {string} A line for each test with the status (passed, failed, etc.) and the test name.\n\t */\n\trenderAsSingleLines(testCaseResults: TestCaseResult | TestCaseResult[]): string {\n\t\tensure.signature(arguments, [[ TestCaseResult, Array ]]);\n\n\t\treturn render(this, testCaseResults).join(\"\\n\");\n\n\t\tfunction render(self: TestRenderer, testCaseResults: TestCaseResult | TestCaseResult[]): string[] {\n\t\t\tconst str = self.#renderMultipleResults(testCaseResults, \"\\n\", TestCaseResult, (testResult: TestCaseResult) => {\n\t\t\t\tconst status = self.renderStatusAsSingleWord(testResult);\n\t\t\t\tconst name = self.renderNameOnOneLine(testResult);\n\n\t\t\t\tlet testDetail = \"\";\n\t\t\t\tlet beforeAfter = \"\";\n\t\t\t\tif (showTestDetail(testResult)) {\n\t\t\t\t\tconst detailSeparator = `\\n  ${summaryColor(\"-->\")}  `;\n\t\t\t\t\tconst beforeAfterResults = [ ...testResult.beforeEach, ...testResult.afterEach ];\n\t\t\t\t\ttestDetail = `${detailSeparator}${TestRenderer.#DESCRIPTION_RENDERING[testResult._status]} the test itself`;\n\t\t\t\t\tbeforeAfter = detailSeparator + render(self, beforeAfterResults).join(detailSeparator);\n\t\t\t\t}\n\n\t\t\t\treturn `${status} ${name}${testDetail}${beforeAfter}`;\n\t\t\t});\n\t\t\treturn str.split(\"\\n\");\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string} A full explanation of this test result.\n\t */\n\trenderAsMultipleLines(testCaseResults: TestCaseResult | TestCaseResult[]): string {\n\t\tensure.signature(arguments, [[ TestSuiteResult, TestCaseResult, Array ]]);\n\n\t\treturn render(this, testCaseResults, \"\\n\\n\\n\");\n\n\t\tfunction render(self: TestRenderer, testCaseResults: TestCaseResult | TestCaseResult[], separator: string): string {\n\t\t\treturn self.#renderMultipleResults(testCaseResults, separator, TestCaseResult, (testResult: TestCaseResult) => {\n\t\t\t\tconst name = self.renderNameOnMultipleLines(testResult);\n\n\t\t\t\tif (showTestDetail(testResult)) {\n\t\t\t\t\treturn renderDetail(self, testResult);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst status = self.renderStatusWithMultiLineDetails(testResult);\n\t\t\t\t\treturn `${name}\\n\\n${status}`;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction renderDetail(self: TestRenderer, testResult: TestCaseResult): string {\n\t\t\tconst chevrons = headerColor(`»»» `);\n\t\t\tconst beforeAfterResults = [ ...testResult.beforeEach, ...testResult.afterEach ];\n\t\t\tconst beforeAfter = `\\n\\n` + self.#renderMultipleResults(beforeAfterResults, `\\n\\n`, TestCaseResult, (detailResult: TestCaseResult) => {\n\t\t\t\tconst status = self.renderStatusWithMultiLineDetails(detailResult);\n\t\t\t\tconst finalName = normalizeName(detailResult.name).pop() as string;\n\t\t\t\treturn chevrons + headerColor(finalName) + `\\n${self.renderNameOnOneLine(detailResult)}\\n\\n${status}`;\n\t\t\t});\n\t\t\tconst test = `\\n\\n${chevrons}${headerColor(\"the test itself\")}\\n`\n\t\t\t\t+ `${self.renderNameOnOneLine(testResult)}\\n\\n${self.renderStatusWithMultiLineDetails(testResult)}`;\n\t\t\treturn `${(self.renderNameOnMultipleLines(testResult))}${beforeAfter}${test}\\n\\n${headerColor(\"«««\")}`;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string} A line for each test that's marked (.only, .skip, etc.) with the mark and the test name.\n\t */\n\trenderMarksAsLines(testResults: TestResult | TestResult[]): string {\n\t\tensure.signature(arguments, [[ TestSuiteResult, TestCaseResult, Array ]]);\n\n\t\treturn this.#renderMultipleResults(testResults, \"\\n\", TestResult, (testResult: TestResult) => {\n\t\t\tconst mark = this.renderMarkAsSingleWord(testResult);\n\t\t\tconst name = this.renderNameOnOneLine(testResult);\n\n\t\t\tif (mark === \"\") return \"\";\n\t\t\telse return `${mark} ${name}`;\n\t\t});\n\n\t}\n\n\t/**\n\t * @returns {string} The name of the test, including parent suites and filename, rendered as a single line.\n\t */\n\trenderNameOnOneLine(testCaseResult: TestResult) {\n\t\tensure.signature(arguments, [ TestResult ]);\n\n\t\tconst filename = testCaseResult.filename === undefined\n\t\t\t? \"\"\n\t\t\t: headerColor(path.basename(testCaseResult.filename)) + \" » \";\n\t\tconst name = normalizeNameOld(testCaseResult).join(\" » \");\n\n\t\treturn `${filename}${name}`;\n\t}\n\n\t/**\n\t * @returns {string} The name of the test, including parent suites and filename, with the suites and filename\n\t *   rendered on a separate line.\n\t */\n\trenderNameOnMultipleLines(testResult: TestResult): string {\n\t\tensure.signature(arguments, [ TestResult ]);\n\n\t\tconst name = normalizeNameOld(testResult);\n\n\t\tconst suites = name.slice(0, name.length - 1);\n\t\tconst test = name[name.length - 1];\n\n\t\tif (testResult.filename !== undefined) suites.unshift(path.basename(testResult.filename));\n\n\t\tconst suitesName = suites.length > 0\n\t\t\t? headerColor(suites[0]) + suites.slice(1).map(name => ` » ${name}`).join(\"\") + \"\\n\" + headerColor(\"» \")\n\t\t\t: \"\";\n\n\t\treturn suitesName + headerColor(test);\n\t}\n\n\t/**\n\t * @returns {string} The color-coded status of the test.\n\t */\n\trenderStatusAsSingleWord(testCaseResult: TestCaseResult) {\n\t\treturn TestRenderer.#DESCRIPTION_RENDERING[testCaseResult.status];\n\t}\n\n\trenderStatusWithMultiLineDetails(testCaseResult: TestCaseResult): string {\n\t\tswitch (testCaseResult._status) {\n\t\t\tcase TestStatus.pass:\n\t\t\tcase TestStatus.skip:\n\t\t\t\treturn TestRenderer.#DESCRIPTION_RENDERING[testCaseResult._status];\n\t\t\tcase TestStatus.fail:\n\t\t\t\treturn (typeof testCaseResult.errorRender === \"string\") ?\n\t\t\t\t\ttestCaseResult.errorRender :\n\t\t\t\t\tutil.inspect(testCaseResult.errorRender, { depth: Infinity });\n\t\t\tcase TestStatus.timeout:\n\t\t\t\treturn timeoutMessageColor(`Timed out after ${testCaseResult.timeout}ms`);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unrecognized test result status: ${testCaseResult._status}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string} The color-coded mark of the test result (.only, etc.), or \"\" if the test result wasn't marked.\n\t */\n\trenderMarkAsSingleWord(testResult: TestResult) {\n\t\tswitch (testResult.mark) {\n\t\t\tcase TestMark.none: return \"(no mark)\";\n\t\t\tcase TestMark.skip: return Colors.brightCyan(\".skip\");\n\t\t\tcase TestMark.only: return Colors.brightCyan(\".only\");\n\t\t\tdefault: ensure.unreachable(`Unrecognized test mark: ${testResult.mark}`);\n\t\t}\n\t}\n\n\t#renderMultipleResults<T>(\n\t\ttestResults: T | T[],\n\t\tseparator: string,\n\t\texpectedType: Function,   // eslint-disable-line @typescript-eslint/no-unsafe-function-type\n\t\trenderFn: (testResult: T) => string,\n\t): string {\n\t\tif (!Array.isArray(testResults)) testResults = [ testResults ];\n\t\ttestResults.forEach((result, i) => ensure.type(result, expectedType, `testResult[${i}]`));\n\n\t\treturn testResults.map(result => renderFn(result)).join(separator);\n\t}\n\n}\n\nfunction normalizeNameOld(testResult: TestResult) {\n\treturn testResult.name.length === 0 ? [ \"(no name)\" ] : [ ...testResult.name ];\n}\n\nfunction normalizeName(name: string[]): string[] {\n\treturn name.length === 0 ? [ \"(no name)\" ] : [ ...name ];\n}\n\nfunction showTestDetail(testResult: TestCaseResult) {\n\tconst beforeAfter = [ ...testResult.beforeEach, ...testResult.afterEach ];\n\tconst allBeforeAfterPass = beforeAfter.every(result => result.status === TestStatus.pass);\n\tconst allBeforeAfterSkipped = beforeAfter.every(result => result.status === TestStatus.skip);\n\n\treturn !(allBeforeAfterPass || (allBeforeAfterSkipped && testResult._status === TestStatus.skip));\n}\n"],"names":["ensure","TestCaseResult","TestMark","TestResult","TestStatus","TestSuiteResult","Colors","path","AssertionError","util","SourceMap","headerColor","brightWhite","bold","highlightColor","stackHighlightColor","brightYellow","errorMessageColor","brightRed","timeoutMessageColor","purple","expectedColor","green","actualColor","diffColor","summaryColor","dim","renderError","name","error","mark","filename","signature","arguments","Array","ANY_TYPE","String","undefined","finalName","normalizeName","pop","renderedError","Error","stack","renderStack","message","inspect","diff","renderDiff","sourceMap","create","filenamesToHighlight","getOriginalFilenames","length","lines","split","highlightedLines","map","line","shouldHighlight","some","includes","replace","join","expected","actual","depth","Infinity","i","Math","max","expectedLine","actualLine","TestRenderer","pass","fail","inverse","skip","cyan","timeout","brightCyan","brightPurple","renderSummary","testSuiteResult","elapsedMs","Number","total","count","renders","renderCount","renderMsEach","filter","render","number","description","color","msEach","toFixed","renderAsCharacters","testCaseResults","testResult","status","renderAsSingleLines","self","str","renderStatusAsSingleWord","renderNameOnOneLine","testDetail","beforeAfter","showTestDetail","detailSeparator","beforeAfterResults","beforeEach","afterEach","_status","renderAsMultipleLines","separator","renderNameOnMultipleLines","renderDetail","renderStatusWithMultiLineDetails","chevrons","detailResult","test","renderMarksAsLines","testResults","renderMarkAsSingleWord","testCaseResult","basename","normalizeNameOld","suites","slice","unshift","suitesName","errorRender","none","only","unreachable","expectedType","renderFn","isArray","forEach","result","type","allBeforeAfterPass","every","allBeforeAfterSkipped"],"mappings":"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"}