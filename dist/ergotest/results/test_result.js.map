{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/ergotest/results/test_result.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\n\nimport * as ensure from \"../../util/ensure.js\";\nimport util from \"node:util\";\nimport { renderError as renderErrorFn, TestRenderer } from \"./test_renderer.js\";\n\nexport const TestStatus = {\n\tpass: \"pass\",\n\tfail: \"fail\",\n\tskip: \"skip\",\n\ttimeout: \"timeout\",\n} as const;\n\nexport type TestStatusValue = typeof TestStatus[keyof typeof TestStatus];\n\nexport const TestMark = {\n\tnone: \"none\",\n\tskip: \"skip\",\n\tonly: \"only\",\n} as const;\n\nexport type TestMarkValue = typeof TestMark[keyof typeof TestMark];\n\nexport interface TestCount {\n\tpass: number;\n\tfail: number;\n\tskip: number;\n\ttimeout: number;\n\ttotal: number;\n}\n\nexport type SerializedTestResult = SerializedTestSuiteResult | SerializedTestCaseResult;\n\nexport interface SerializedTestSuiteResult {\n\ttype: \"TestSuiteResult\";\n\tname: string[];\n\tmark: TestMarkValue;\n\tfilename?: string;\n\ttests: SerializedTestResult[];\n\tbeforeAll: SerializedTestCaseResult[];\n\tafterAll: SerializedTestCaseResult[];\n}\n\nexport interface SerializedTestCaseResult {\n\ttype: \"TestCaseResult\";\n\tmark: TestMarkValue;\n\tbeforeEach: SerializedRunResult[];\n\tafterEach: SerializedRunResult[];\n\tit: SerializedRunResult;\n}\n\nexport interface SerializedRunResult {\n\ttype: \"RunResult\";\n\tname: string[];\n\tfilename?: string;\n\tstatus: TestStatusValue;\n\terrorMessage?: string;\n\terrorRender?: unknown;\n\ttimeout?: number;\n}\n\nexport type RenderErrorFn = (name: string[], error: unknown, filename?: string) => unknown;\n\n/**\n * The result of a running a test. Can be a single test case or a suite of nested test results.\n */\nexport abstract class TestResult {\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {objects} serializedTestResult The serialized test result.\n\t * @returns {TestSuiteResult | TestCaseResult} The result object.\n\t * @see TestSuiteResult#serialize\n\t * @see TestCaseResult#serialize\n\t */\n\tstatic deserialize(serializedTestResult: SerializedTestResult): TestResult {\n\t\tensure.signatureMinimum(arguments, [{ type: String }]);\n\n\t\tconst type = serializedTestResult.type;\n\t\tswitch (type) {\n\t\t\tcase \"TestSuiteResult\": return TestSuiteResult.deserialize(serializedTestResult);\n\t\t\tcase \"TestCaseResult\": return TestCaseResult.deserialize(serializedTestResult);\n\t\t\tdefault: ensure.unreachable(`Unrecognized type '${type}' in serialized test result: ${serializedTestResult}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string []} The name of the test (or suite), and all enclosing suites, with the outermost suite first.\n\t *   Does not include the file name.\n\t */\n\tabstract get name(): string[];\n\n\t/**\n\t * @returns {string | undefined} The file that contained the test (or suite), if known.\n\t */\n\tabstract get filename(): string | undefined;\n\n\t/**\n\t * @return { TestMark } Whether the test (or suite) was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tabstract get mark(): TestMarkValue;\n\n\t/**\n\t * @returns {TestCaseResult[]} All the test results, excluding test suites, flattened into a single list.\n\t */\n\tabstract allTests(): TestCaseResult[];\n\n\t/**\n\t * @returns {TestCaseResult[]} All test results, with a mark (.only, etc.) that matches the requested marks,\n\t *   flattened into a single list, including test suites. However, if you access the properties of the test suites,\n\t *   such as {@link TestSuiteResult.tests}, those properties wonâ€™t be filtered.\n\t */\n\tabstract allMatchingMarks(...marks: TestMarkValue[]): TestResult[];\n\n\t/**\n\t * Convert this result into a bare object later deserialization.\n\t * @returns {SerializedTestSuiteResult} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tabstract serialize(): SerializedTestResult;\n\n\t/**\n\t * Determine if this test result is identical to another test result. To be identical, they must have the same\n\t * results, in the same order, with the same names, filenames, and marks (.only etc.).\n\t * @param {any} that The thing to compare against\n\t * @returns {boolean}\n\t */\n\tabstract equals(that: TestResult): boolean;\n}\n\n/**\n * The result of running a test suite.\n */\nexport class TestSuiteResult extends TestResult {\n\n\t/**\n\t * Create a TestSuiteResult for a suite of tests.\n\t * @param {string|string[]} [options.name] The name of the test. Can be a list of names.\n\t * @param {TestResult[]} [options.tests] The nested tests in this suite (can be test suites or individual test cases).\n\t * @param {TestCaseResult[]} [options.beforeAll] The beforeAll() blocks in this suite.\n\t * @param {TestCaseResult[]} [options.afterAll] The afterAll() blocks in this suite.\n\t * @param {string} [options.filename] The file that contained this suite (optional).\n\t * @param {TestMarkValue} [options.mark] Whether this suite was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestSuiteResult} The result.\n\t */\n\tstatic create({\n\t\tname = [],\n\t\ttests = [],\n\t\tbeforeAll = [],\n\t\tafterAll = [],\n\t\tfilename,\n\t\tmark = TestMark.none\n\t}: {\n\t\tname?: string[],\n\t\ttests?: TestResult[],\n\t\tbeforeAll?: TestCaseResult[],\n\t\tafterAll?: TestCaseResult[],\n\t\tfilename?: string,\n\t\tmark?: TestMarkValue,\n\t} = {}): TestSuiteResult {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\tname: [ undefined, String, Array ],\n\t\t\ttests: [ undefined, Array ],\n\t\t\tbeforeAll: [ undefined, Array ],\n\t\t\tafterAll: [ undefined, Array ],\n\t\t\tfilename: [ undefined, String ],\n\t\t\tmark: [ undefined, String ]\n\t\t}]]);\n\n\t\treturn new TestSuiteResult(name, tests, beforeAll, afterAll, mark, filename);\n\t}\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {SerializedTestSuiteResult} serializedTestResult The serialized test result.\n\t * @returns {TestSuiteResult} The result object.\n\t * @see TestResult#deserialize\n\t */\n\tstatic deserialize(suite: SerializedTestSuiteResult): TestSuiteResult {\n\t\tensure.signature(arguments, [{\n\t\t\ttype: String,\n\t\t\tname: Array,\n\t\t\tmark: String,\n\t\t\tfilename: [ undefined, String ],\n\t\t\ttests: Array,\n\t\t\tbeforeAll: Array,\n\t\t\tafterAll: Array,\n\t\t}], [ \"serialized TestSuiteResult\" ]);\n\n\t\tconst { name, filename, mark, tests, beforeAll, afterAll } = suite;\n\t\tconst deserializedTests = tests.map(test => TestResult.deserialize(test));\n\t\tconst deserializedBeforeAll = beforeAll.map(test => TestCaseResult.deserialize(test));\n\t\tconst deserializedAfterAll = afterAll.map(test => TestCaseResult.deserialize(test));\n\n\t\treturn new TestSuiteResult(name, deserializedTests, deserializedBeforeAll, deserializedAfterAll, mark, filename);\n\t}\n\n\tprivate readonly _name: string[];\n\tprivate readonly _tests: TestResult[];\n\tprivate readonly _beforeAll: TestCaseResult[];\n\tprivate readonly _afterAll: TestCaseResult[];\n\tprivate readonly _mark: TestMarkValue;\n\tprivate readonly _filename?: string;\n\n\t/** Internal use only. (Use {@link TestResult.suite} instead.) */\n\tconstructor(name: string[], tests: TestResult[], beforeAll: TestCaseResult[], afterAll: TestCaseResult[], mark: TestMarkValue, filename?: string) {\n\t\tsuper();\n\t\tthis._name = name;\n\t\tthis._tests = tests;\n\t\tthis._beforeAll = beforeAll;\n\t\tthis._afterAll = afterAll;\n\t\tthis._mark = mark;\n\t\tthis._filename = filename;\n\t}\n\n\t/**\n\t * @returns {string []} The name of the suite, and all enclosing suites, with the outermost suite first.\n\t *   Does not include the file name.\n\t */\n\tget name(): string[] {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * @returns {string | undefined} The file that contained the suite, if known.\n\t */\n\tget filename(): string | undefined {\n\t\treturn this._filename;\n\t}\n\n\t/**\n\t * @return { TestMarkValue } Whether the test was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tget mark(): TestMarkValue {\n\t\treturn this._mark;\n\t}\n\n\t/**\n\t * @returns { TestResult[] } The tests in this suite, which can either be test case results or test suite results.\n\t */\n\tget tests(): TestResult[] {\n\t\treturn this._tests;\n\t}\n\n\t/**\n\t * @returns { TestCaseResult[] } The beforeAll() blocks for this suite.\n\t */\n\tget beforeAll(): TestCaseResult[] {\n\t\treturn this._beforeAll;\n\t}\n\n\t/**\n\t * @returns { TestCaseResult[] } The afterAll() blocks for this suite.\n\t */\n\tget afterAll(): TestCaseResult[] {\n\t\treturn this._afterAll;\n\t}\n\n\t/**\n\t * Convert this suite to a nicely-formatted string. The string describes the tests that have marks (such as .only)\n\t * and provides details about the tests that have failed or timed out. It doesn't provide any details about the tests\n\t * that have passed or been skipped, except for the ones that have marks. After the details, it displays a summary of\n\t * the number of tests that have passed, failed, etc., and the average time required per test.\n\t *\n\t * This is a convenience method. For more control over rendering, use {@link TestRenderer} instead.\n\t *\n\t * @param {string} [preamble=\"\"] A string to write before the test results, but only if there are any marks or errors.\n\t * @param {number} elapsedMs The total time required to run the test suite, in milliseconds.\n\t *   If there are no marks or errors, the preamble is ignored. Defaults to an empty string.\n\t * @returns The formatted string.\n\t */\n\trender(preamble: string = \"\", elapsedMs?: number): string {\n\t\tensure.signature(arguments, [ [ undefined, String ], [ undefined, Number ]]);\n\n\t\tconst renderer = TestRenderer.create();\n\t\tconst marks = this.allMarkedResults();\n\t\tconst errors = this.allMatchingTests(TestStatus.fail, TestStatus.timeout);\n\n\t\tconst markRender = renderer.renderMarksAsLines(marks);\n\t\tconst errorRender = renderer.renderAsMultipleLines(errors);\n\t\tconst summaryRender = renderer.renderSummary(this, elapsedMs);\n\n\t\tif (marks.length > 0 && errors.length > 0) {\n\t\t\treturn preamble + markRender + \"\\n\\n\\n\" + errorRender + \"\\n\\n\" + summaryRender;\n\t\t}\n\t\telse if (marks.length > 0) {\n\t\t\treturn preamble + markRender + \"\\n\\n\" + summaryRender;\n\t\t}\n\t\telse if (errors.length > 0) {\n\t\t\treturn preamble + errorRender + \"\\n\\n\" + summaryRender;\n\t\t}\n\t\telse {\n\t\t\treturn summaryRender;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} All the test results, excluding test suites, flattened into a single list.\n\t */\n\tallTests(): TestCaseResult[] {\n\t\tensure.signature(arguments, []);\n\n\t\treturn [\n\t\t\t...this._beforeAll,\n\t\t\t...this._afterAll,\n\t\t\t...this._tests.flatMap(result => result.allTests()),\n\t\t];\n\t}\n\n\t/**\n\t * Finds all the test results that match the provided statuses.\n\t * @param {TestStatus[]} statuses The statuses to match.\n\t * @returns {TestCaseResult[]} The test results.\n\t */\n\tallMatchingTests(...statuses: TestStatusValue[]): TestCaseResult[] {\n\t\treturn this.allTests().filter(test => statuses.includes(test.status));\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} All test results, with a mark (.only, etc.) that matches the requested marks,\n\t *   flattened into a single list, including test suites. However, if you access the properties of the test suites,\n\t *   such as {@link TestSuiteResult.tests}, those properties wonâ€™t be filtered.\n\t */\n\tallMarkedResults(): TestResult[] {\n\t\tensure.signature(arguments, []);\n\n\t\tconst allMarks = new Set(Object.values(TestMark));\n\t\tallMarks.delete(TestMark.none);\n\t\treturn this.allMatchingMarks.apply(this, [ ...allMarks ]);\n\t}\n\n\tallMatchingMarks(...marks: TestMarkValue[]): TestResult[] {\n\t\tensureValidMarks(marks);\n\n\t\tconst results = new Set<TestResult>();\n\t\tif (marks.includes(this.mark)) results.add(this);\n\n\t\tconst collect = (result: TestResult) => {\n\t\t\tif (marks.includes(result.mark)) results.add(result);\n\t\t\tresult.allMatchingMarks.apply(result, marks).forEach(subResult => results.add(subResult));\n\t\t};\n\n\t\tthis._beforeAll.forEach(collect);\n\t\tthis._afterAll.forEach(collect);\n\t\tthis._tests.forEach(collect);\n\n\t\treturn [ ...results ];\n\t}\n\n\t/**\n\t * @returns {string[]} All the test files with 100% passing tests--nothing that was skipped, failed, or timed out.\n\t */\n\tallPassingFiles(): string[] {\n\t\tensure.signature(arguments, []);\n\n\t\tconst allFiles = new Set<string>();\n\t\tconst notPassFiles = new Set<string>();\n\t\tthis.allTests()\n\t\t\t.filter(test => test.filename !== undefined)\n\t\t\t.forEach(test => {\n\t\t\t\tallFiles.add(test.filename!);\n\t\t\t\tif (!test.isPass()) notPassFiles.add(test.filename!);\n\t\t\t});\n\n\t\treturn [ ...differencePolyfill(allFiles, notPassFiles) ];\n\n\t\tfunction differencePolyfill<T>(leftSet: Set<T>, rightSet: Set<T>): Set<T> {\n\t\t\t// Included in Node v22.0; remove this polyfill and replace with left.difference(right) when that enters LTS\n\t\t\treturn new Set([ ...leftSet ].filter(value => !rightSet.has(value)));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {TestCount} A summary count of this suite's results. Includes a count of each type of test result and the\n\t *   total number of tests.\n\t */\n\tcount(): TestCount {\n\t\tensure.signature(arguments, []);\n\n\t\tconst count = {\n\t\t\t[TestStatus.pass]: 0,\n\t\t\t[TestStatus.fail]: 0,\n\t\t\t[TestStatus.skip]: 0,\n\t\t\t[TestStatus.timeout]: 0,\n\t\t\ttotal: 0,\n\t\t};\n\n\t\tthis.allTests().forEach(test => {\n\t\t\tcount[test.status]++;\n\t\t\tcount.total++;\n\t\t});\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * Convert this suite into a bare object later deserialization.\n\t * @returns {SerializedTestSuiteResult} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tserialize(): SerializedTestSuiteResult {\n\t\tensure.signature(arguments, []);\n\n\t\treturn {\n\t\t\ttype: \"TestSuiteResult\",\n\t\t\tname: this._name,\n\t\t\tmark: this._mark,\n\t\t\tfilename: this._filename,\n\t\t\ttests: this._tests.map(test => test.serialize()),\n\t\t\tbeforeAll: this._beforeAll.map(test => test.serialize()),\n\t\t\tafterAll: this._afterAll.map(test => test.serialize()),\n\t\t};\n\t}\n\n\tequals(that: TestResult): boolean {\n\t\tensure.signature(arguments, [ ensure.ANY_TYPE ]);\n\n\t\tif (!(that instanceof TestSuiteResult)) return false;\n\t\tif (this._mark !== that._mark) return false;\n\n\t\tif (!compareTestResults(this._tests, that._tests)) return false;\n\t\tif (!compareTestResults(this._beforeAll, that._beforeAll)) return false;\n\t\tif (!compareTestResults(this._afterAll, that._afterAll)) return false;\n\n\t\tconst sameName = util.isDeepStrictEqual(this._name, that._name);\n\t\treturn sameName && this._filename === that._filename;\n\n\t\tfunction compareTestResults(thisTests: TestResult[], thatTests: TestResult[]): boolean {\n\t\t\tif (thisTests.length !== thatTests.length) return false;\n\t\t\tfor (let i = 0; i < thisTests.length; i++) {\n\t\t\t\tconst thisResult = thisTests[i]!;\n\t\t\t\tconst thatResult = thatTests[i]!;\n\t\t\t\tif (!thisResult.equals(thatResult)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n}\n\n\n/**\n * The result of running an individual test.\n */\nexport class TestCaseResult extends TestResult {\n\n\tprivate readonly _mark: TestMarkValue;\n\tprivate _beforeEach: RunResult[];\n\tprivate _afterEach: RunResult[];\n\tprivate readonly _it: RunResult;\n\n\tstatic create({\n\t\tmark = TestMark.none,\n\t\tbeforeEach = [],\n\t\tafterEach = [],\n\t\tit,\n\t}: {\n\t\tmark?: TestMarkValue\n\t\tbeforeEach?: RunResult[],\n\t\tafterEach?: RunResult[],\n\t\tit: RunResult,\n\t}): TestCaseResult {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\tmark: [ undefined, String ],\n\t\t\tbeforeEach: [ undefined, Array ],\n\t\t\tafterEach: [ undefined, Array ],\n\t\t\tit: RunResult,\n\t\t}]]);\n\n\t\treturn new TestCaseResult({ mark, beforeEach, afterEach, it });\n\t}\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {object} serializedResult The serialized test result.\n\t * @returns {TestCaseResult} The result object.\n\t * @see TestResult#deserialize\n\t */\n\tstatic deserialize({ mark, beforeEach, afterEach, it }: SerializedTestCaseResult): TestCaseResult {\n\t\tensure.signature(arguments, [{\n\t\t\ttype: String,\n\t\t\tmark: String,\n\t\t\tbeforeEach: [ undefined, Array ],\n\t\t\tafterEach: [ undefined, Array ],\n\t\t\tit: Object,\n\t\t}], [ \"serialized TestCaseResult\" ]);\n\n\t\tconst deserializedBeforeEach = beforeEach.map(each => RunResult.deserialize(each));\n\t\tconst deserializedAfterEach = afterEach.map(each => RunResult.deserialize(each));\n\n\t\treturn new TestCaseResult({\n\t\t\tmark,\n\t\t\tbeforeEach: deserializedBeforeEach,\n\t\t\tafterEach: deserializedAfterEach,\n\t\t\tit: RunResult.deserialize(it),\n\t\t});\n\t}\n\n\t/** Internal use only. (Use {@link TestResult} factory methods instead.) */\n\tconstructor(\n\t\t{\n\t\t\tbeforeEach = [],\n\t\t\tafterEach = [],\n\t\t\tit,\n\t\t\tmark,\n\t\t}: {\n\t\t\tbeforeEach?: RunResult[],\n\t\t\tafterEach?: RunResult[],\n\t\t\tit: RunResult,\n\t\t\tmark?: TestMarkValue\n\t\t},\n\t) {\n\t\tsuper();\n\t\tthis._mark = mark ?? TestMark.none;\n\t\tthis._beforeEach = beforeEach;\n\t\tthis._afterEach = afterEach;\n\t\tthis._it = it;\n\t}\n\n\t/**\n\t * @returns {string []} The name of the test, and all enclosing suites, with the outermost suite first.\n\t *   Does not include the file name.\n\t */\n\tget name(): string[] {\n\t\treturn this._it.name;\n\t}\n\n\t/**\n\t * @returns {string | undefined} The file that contained the test, if known.\n\t */\n\tget filename(): string | undefined {\n\t\treturn this._it.filename;\n\t}\n\n\t/**\n\t * @returns {TestStatusValue} Whether this test passed, failed, etc., taking into account the status of beforeEach()\n\t *   and afterEach() results.\n\t */\n\tget status(): TestStatusValue {\n\t\tconst consolidatedBefore = this._beforeEach.reduce(consolidateRunResult, TestStatus.pass);\n\t\tconst consolidatedBeforeAndAfter = this._afterEach.reduce(consolidateRunResult, consolidatedBefore);\n\n\t\tif (consolidatedBeforeAndAfter === TestStatus.pass && this._it.status === TestStatus.skip) return TestStatus.skip;\n\t\telse return consolidateStatus(consolidatedBeforeAndAfter, this._it.status);\n\n\t\tfunction consolidateRunResult(previousStatus: TestStatusValue, runResult: RunResult) {\n\t\t\treturn consolidateStatus(previousStatus, runResult.status);\n\t\t}\n\n\t\tfunction consolidateStatus(left: TestStatusValue, right: TestStatusValue) {\n\t\t\tif (left === TestStatus.fail || right === TestStatus.fail) return TestStatus.fail;\n\t\t\telse if (left === TestStatus.timeout || right === TestStatus.timeout) return TestStatus.timeout;\n\t\t\telse if (left === TestStatus.pass || right === TestStatus.pass) return TestStatus.pass;\n\t\t\telse return TestStatus.skip;\n\t\t}\n\t}\n\n\t/**\n\t * @return { TestMark } Whether the test was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tget mark(): TestMarkValue {\n\t\treturn this._mark;\n\t}\n\n\t/**\n\t * @returns { RunResult[] } The beforeEach() blocks for this test.\n\t */\n\tget beforeEach(): RunResult[] {\n\t\treturn this._beforeEach;\n\t}\n\n\t/**\n\t * @returns { RunResult[] } The afterEach() blocks for this test.\n\t */\n\tget afterEach(): RunResult[] {\n\t\treturn this._afterEach;\n\t}\n\n\t/**\n\t * @returns { RunResult } The it() result for this test.\n\t */\n\tget it(): RunResult {\n\t\treturn this._it;\n\t}\n\n\t/**\n\t * @returns {string} A short description of the reason this test failed. If the error is an Error instance, it's\n\t *   equal to the error's `message` property. Otherwise, the error is converted to a string using `util.inspect()`.\n\t * @throws {Error} Throws an error if this test didn't fail.\n\t */\n\tget errorMessage(): string {\n\t\treturn this._it.errorMessage;\n\t}\n\n\t/**\n\t * @returns {unknown} The complete rendering of the reason this test failed. May be of any type, depending on how\n\t *   `renderError()` in TestOptions is defined, but it defaults to a string.\n\t * @throws {Error} Throws an error if this test didn't fail.\n\t */\n\tget errorRender(): unknown {\n\t\treturn this._it.errorRender;\n\t}\n\n\t/**\n\t * @returns {number} The timeout that this test didn't satisfy. Note that this is not the actual amount of run time\n\t *   of the test.\n\t * @throws {Error} Throws an error if this test didn't time out.\n\t */\n\tget timeout(): number {\n\t\treturn this._it.timeout;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test passed.\n\t */\n\tisPass(): boolean {\n\t\tensure.signature(arguments, []);\n\n\t\treturn this.status === TestStatus.pass;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test failed.\n\t */\n\tisFail(): boolean {\n\t\tensure.signature(arguments, []);\n\n\t\treturn this.status === TestStatus.fail;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test was skipped.\n\t */\n\tisSkip(): boolean {\n\t\tensure.signature(arguments, []);\n\n\t\treturn this.status === TestStatus.skip;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test timed out.\n\t */\n\tisTimeout(): boolean {\n\t\tensure.signature(arguments, []);\n\n\t\treturn this.status === TestStatus.timeout;\n\t}\n\n\t/**\n\t * Render the test case as a single color-coded character.\n\t *\n\t * This is a convenience method that calls {@link TestRenderer.renderAsCharacters()}. For more control over rendering,\n\t * use that class instead.\n\t *\n\t * @returns The formatted character.\n\t */\n\trenderAsCharacter(): string {\n\t\tensure.signature(arguments, []);\n\n\t\treturn TestRenderer.create().renderAsCharacters(this);\n\t}\n\n\t/**\n\t * Render the test case as a single line containing its status (pass, fail, etc.) and names.\n\t *\n\t * This is a convenience method that calls {@link TestRenderer.renderAsSingleLines()}. For more control over\n\t * rendering, use that class instead.\n\t *\n\t * @returns The formatted line.\n\t */\n\trenderAsSingleLine(): string {\n\t\tensure.signature(arguments, []);\n\n\t\treturn TestRenderer.create().renderAsSingleLines(this);\n\t}\n\n\t/**\n\t * Render the test case as a multiple lines containing all of its details.\n\t *\n\t * This is a convenience method that calls {@link TestRenderer.renderAsMultipleLines()}. For more control over\n\t * rendering, use that class instead.\n\t *\n\t * @returns The formatted lines.\n\t */\n\trenderAsMultipleLines(): string {\n\t\tensure.signature(arguments, []);\n\n\t\treturn TestRenderer.create().renderAsMultipleLines(this);\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} This test converted into a list of one.\n\t */\n\tallTests(): TestCaseResult[] {\n\t\tensure.signature(arguments, []);\n\n\t\treturn [ this ];\n\t}\n\n\tallMatchingMarks(...marks: TestMarkValue[]): TestResult[] {\n\t\tensureValidMarks(marks);\n\n\t\tif (marks.includes(this._mark)) return [ this ];\n\t\telse return [];\n\t}\n\n\t/**\n\t * Convert this result into a bare object for later deserialization.\n\t * @returns {object} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tserialize(): SerializedTestCaseResult {\n\t\tensure.signature(arguments, []);\n\n\t\treturn {\n\t\t\ttype: \"TestCaseResult\",\n\t\t\tmark: this._mark,\n\t\t\tbeforeEach: this._beforeEach.map(each => each.serialize()),\n\t\t\tafterEach: this._afterEach.map(each => each.serialize()),\n\t\t\tit: this._it.serialize(),\n\t\t};\n\t}\n\n\tequals(that: TestResult): boolean {\n\t\tif (!(that instanceof TestCaseResult)) return false;\n\n\t\tconst sameMark = this._mark === that._mark;\n\t\tconst sameIt = this._it.equals(that._it);\n\t\tconst sameBeforeEach = compareRunResults(this._beforeEach, that._beforeEach);\n\t\tconst sameAfterEach = compareRunResults(this._afterEach, that._afterEach);\n\n\t\treturn sameMark\n\t\t\t&& sameIt\n\t\t\t&& sameBeforeEach\n\t\t\t&& sameAfterEach;\n\n\t\tfunction compareRunResults(thisResults: RunResult[], thatResults: RunResult[]): boolean {\n\t\t\tif (thisResults.length !== thatResults.length) return false;\n\t\t\tfor (let i = 0; i < thisResults.length; i++) {\n\t\t\t\tconst thisResult = thisResults[i]!;\n\t\t\t\tconst thatResult = thatResults[i]!;\n\t\t\t\tif (!thisResult.equals(thatResult)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n}\n\n\n/**\n * The result of running an individual test function, such as beforeAll(), afterAll(), beforeEach(), afterEach(), or\n * it().\n */\nexport class RunResult {\n\n\tprivate readonly _name: string[];\n\tprivate readonly _filename?: string;\n\tprivate readonly _status: TestStatusValue;\n\tprivate readonly _errorMessage?: string;\n\tprivate readonly _errorRender?: unknown;\n\tprivate readonly _timeout?: number;\n\n\t/**\n\t * Create a RunResult for a test function that completed normally.\n\t * @param {string|string[]} options.name The name of the test function. Can be a list of names.\n\t * @param {string} [options.filename] The file that contained this test function (optional).\n\t * @returns {RunResult} The result.\n\t */\n\tstatic pass({\n\t\tname,\n\t\tfilename,\n\t}: {\n\t\tname: string[],\n\t\tfilename?: string,\n\t}): RunResult {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\tname: Array,\n\t\t\tfilename: [ undefined, String ],\n\t\t}]]);\n\n\t\treturn new RunResult({ name, filename, status: TestStatus.pass });\n\t}\n\n\t/**\n\t * Create a TestResult for a test function that threw an exception.\n\t * @param {string|string[]} options.name The name of the test function. Can be a list of names.\n\t * @param {string} [options.filename] The file that contained this test (optional).\n\t * @param {unknown} options.error The error that occurred.\n\t * @param {(name: string, error: unknown, mark: TestMarkValue, filename?: string) => unknown} [options.renderError]\n\t *   The function to use to render the error into a string (defaults to {@link renderError})\n\t * @returns {RunResult} The result.\n\t */\n\tstatic fail(\n\t\t{\n\t\t\tname,\n\t\t\tfilename,\n\t\t\terror,\n\t\t\trenderError = renderErrorFn,\n\t\t}: {\n\t\t\tname: string[],\n\t\t\tfilename?: string,\n\t\t\terror: unknown,\n\t\t\trenderError?: RenderErrorFn\n\t\t},\n\t): RunResult {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\tname: Array,\n\t\t\tfilename: [ undefined, String ],\n\t\t\terror: ensure.ANY_TYPE,\n\t\t\trenderError: [ undefined, Function ],\n\t\t}]]);\n\n\t\tlet errorMessage: string;\n\t\tif (error instanceof Error) errorMessage = error.message ?? \"\";\n\t\telse if (typeof error === \"string\") errorMessage = error;\n\t\telse errorMessage = util.inspect(error, { depth: Infinity });\n\n\t\tconst errorRender = renderError(name, error, filename);\n\n\t\treturn new RunResult({ name, filename, status: TestStatus.fail, errorMessage, errorRender });\n\t}\n\n\t/**\n\t * Create a RunResult for a test function that was skipped.\n\t * @param {string|string[]} options.name The name of the test function. Can be a list of names.\n\t * @param {string} [options.filename] The file that contained this test (optional).\n\t * @returns {RunResult} The result.\n\t */\n\tstatic skip(\n\t\t{\n\t\t\tname,\n\t\t\tfilename,\n\t\t}: {\n\t\t\tname: string[],\n\t\t\tfilename?: string,\n\t\t}\n\t): RunResult {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\tname: Array,\n\t\t\tfilename: [ undefined, String ],\n\t\t\tmark: [ undefined, String ]\n\t\t}]]);\n\n\t\treturn new RunResult({ name, filename, status: TestStatus.skip });\n\t}\n\n\t/**\n\t * Create a RunResult for a test function that timed out.\n\t * @param {string|string[]} options.name The name of the test function. Can be a list of names.\n\t * @param {string} [options.filename] The file that contained this test (optional).\n\t * @param {number} options.timeout The length of the timeout (not the actual time taken by the function).\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic timeout(\n\t\t{\n\t\t\tname,\n\t\t\tfilename,\n\t\t\ttimeout,\n\t\t}: {\n\t\t\tname: string[],\n\t\t\tfilename?: string,\n\t\t\ttimeout: number,\n\t\t},\n\t): RunResult {\n\t\tensure.signature(arguments, [[ undefined, {\n\t\t\tname: Array,\n\t\t\tfilename: [ undefined, String ],\n\t\t\ttimeout: Number,\n\t\t}]]);\n\n\t\treturn new RunResult({ name, filename, status: TestStatus.timeout, timeout });\n\t}\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized run result back into a RunResult instance.\n\t * @param {object} serializedResult The serialized run result.\n\t * @returns {TestRunResult} The result object.\n\t * @see TestResult#deserialize\n\t */\n\tstatic deserialize(serializedResult: SerializedRunResult): RunResult {\n\t\tensure.signature(arguments, [{\n\t\t\ttype: String,\n\t\t\tname: Array,\n\t\t\tfilename: [ undefined, String ],\n\t\t\tstatus: String,\n\t\t\terrorMessage: [ undefined, String ],\n\t\t\terrorRender: ensure.ANY_TYPE,\n\t\t\ttimeout: [ undefined, Number ],\n\t\t}], [ \"serialized RunResult\" ]);\n\n\t\treturn new RunResult(serializedResult);\n\t}\n\n\t/**\n\t * @private\n\t */\n\tconstructor({\n\t\tname,\n\t\tfilename,\n\t\tstatus,\n\t\terrorMessage,\n\t\terrorRender,\n\t\ttimeout,\n\t}: {\n\t\tname: string[],\n\t\tfilename?: string,\n\t\tstatus: TestStatusValue,\n\t\terrorMessage?: string,\n\t\terrorRender?: unknown,\n\t\ttimeout?: number\n\t}) {\n\t\tthis._name = name;\n\t\tthis._filename = filename;\n\t\tthis._status = status;\n\t\tthis._errorMessage = errorMessage;\n\t\tthis._errorRender = errorRender;\n\t\tthis._timeout = timeout;\n\t}\n\n\t/**\n\t * @returns {string []} The name of the test function, and all enclosing suites, with the outermost suite first.\n\t *   Does not include the file name.\n\t */\n\tget name(): string[] {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * @returns {string | undefined} The file that contained the test function, if known.\n\t */\n\tget filename(): string | undefined {\n\t\treturn this._filename;\n\t}\n\n\t/**\n\t * @returns {TestStatusValue} Whether this test function passed (completed normally), failed (threw an exception),\n\t *   timed out, or was skipped.\n\t */\n\tget status(): TestStatusValue {\n\t\treturn this._status;\n\t}\n\n\t/**\n\t * @returns {string} A short description of the reason this test failed. If the error is an Error instance, it's\n\t *   equal to the error's `message` property. Otherwise, the error is converted to a string using `util.inspect()`.\n\t * @throws {Error} Throws an error if this test didn't fail.\n\t */\n\tget errorMessage(): string {\n\t\tensure.that(this.status === TestStatus.fail, \"Attempted to retrieve error message from a test that didn't fail\");\n\t\treturn this._errorMessage!;\n\t}\n\n\t/**\n\t * @returns {unknown} The complete rendering of the reason this test failed. May be of any type, depending on how\n\t *   `renderError()` in TestOptions is defined, but it defaults to a string.\n\t * @throws {Error} Throws an error if this test didn't fail.\n\t */\n\tget errorRender(): unknown {\n\t\tensure.that(this.status === TestStatus.fail, \"Attempted to retrieve error render from a test that didn't fail\");\n\t\treturn this._errorRender!;\n\t}\n\n\t/**\n\t * @returns {number} The timeout that this test didn't satisfy. Note that this is not the actual amount of run time\n\t *   of the test.\n\t * @throws {Error} Throws an error if this test didn't time out.\n\t */\n\tget timeout(): number {\n\t\tensure.that(this.status === TestStatus.timeout, \"Attempted to retrieve timeout from a test that didn't time out\");\n\t\treturn this._timeout!;\n\t}\n\n\tequals(that: RunResult): boolean {\n\t\tif (!(that instanceof RunResult)) return false;\n\n\t\tconst sameStatus = this._status === that._status;\n\t\tconst sameFilename = this.filename === that.filename;\n\t\tconst sameName = util.isDeepStrictEqual(this._name, that._name);\n\t\tconst sameError = this.status !== TestStatus.fail || this._errorMessage === that._errorMessage;\n\t\tconst sameTimeout = this._status !== TestStatus.timeout || this._timeout === that._timeout;\n\n\t\treturn sameName && sameFilename && sameStatus && sameError && sameTimeout;\n\t}\n\n\t/**\n\t * Convert this result into a bare object later deserialization.\n\t * @returns {object} The serialized object.\n\t * @see RunResult.deserialize\n\t */\n\tserialize(): SerializedRunResult {\n\t\tensure.signature(arguments, []);\n\n\t\treturn {\n\t\t\ttype: \"RunResult\",\n\t\t\tname: this._name,\n\t\t\tfilename: this._filename,\n\t\t\tstatus: this._status,\n\t\t\terrorMessage: this._errorMessage,\n\t\t\terrorRender: this._errorRender,\n\t\t\ttimeout: this._timeout,\n\t\t};\n\t}\n\n}\n\n\nfunction ensureValidMarks(marks: TestMarkValue[]) {\n\tconst validMarks = Object.values(TestMark);\n\tmarks.forEach((mark, i) => {\n\t\tensure.that(validMarks.includes(mark), `Argument #${i} was '${mark}', which isn't a valid mark`);\n\t});\n}"],"names":["ensure","util","renderError","renderErrorFn","TestRenderer","TestStatus","pass","fail","skip","timeout","TestMark","none","only","TestResult","deserialize","serializedTestResult","signatureMinimum","arguments","type","String","TestSuiteResult","TestCaseResult","unreachable","create","name","tests","beforeAll","afterAll","filename","mark","signature","undefined","Array","suite","deserializedTests","map","test","deserializedBeforeAll","deserializedAfterAll","_name","_tests","_beforeAll","_afterAll","_mark","_filename","constructor","render","preamble","elapsedMs","Number","renderer","marks","allMarkedResults","errors","allMatchingTests","markRender","renderMarksAsLines","errorRender","renderAsMultipleLines","summaryRender","renderSummary","length","allTests","flatMap","result","statuses","filter","includes","status","allMarks","Set","Object","values","delete","allMatchingMarks","apply","ensureValidMarks","results","add","collect","forEach","subResult","allPassingFiles","allFiles","notPassFiles","isPass","differencePolyfill","leftSet","rightSet","value","has","count","total","serialize","equals","that","ANY_TYPE","compareTestResults","sameName","isDeepStrictEqual","thisTests","thatTests","i","thisResult","thatResult","_beforeEach","_afterEach","_it","beforeEach","afterEach","it","RunResult","deserializedBeforeEach","each","deserializedAfterEach","consolidatedBefore","reduce","consolidateRunResult","consolidatedBeforeAndAfter","consolidateStatus","previousStatus","runResult","left","right","errorMessage","isFail","isSkip","isTimeout","renderAsCharacter","renderAsCharacters","renderAsSingleLine","renderAsSingleLines","sameMark","sameIt","sameBeforeEach","compareRunResults","sameAfterEach","thisResults","thatResults","_status","_errorMessage","_errorRender","_timeout","error","Function","Error","message","inspect","depth","Infinity","serializedResult","sameStatus","sameFilename","sameError","sameTimeout","validMarks"],"mappings":"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"}