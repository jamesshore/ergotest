{"version":3,"sources":["/Users/jshore/Documents/Projects/ergotest/src/ergotest/test_result.ts"],"sourcesContent":["// Copyright Titanium I.T. LLC. License granted under terms of \"The MIT License.\"\n\nimport * as ensure from \"../util/ensure.js\";\nimport util from \"node:util\";\nimport { renderError as renderErrorFn, TestRenderer } from \"./test_renderer.js\";\n\nexport const TestStatus = {\n\tpass: \"pass\",\n\tfail: \"fail\",\n\tskip: \"skip\",\n\ttimeout: \"timeout\",\n} as const;\n\nexport type TestStatusValue = typeof TestStatus[keyof typeof TestStatus];\n\nexport const TestMark = {\n\tnone: \"none\",\n\tskip: \"skip\",\n\tonly: \"only\",\n} as const;\n\nexport type TestMarkValue = typeof TestMark[keyof typeof TestMark];\n\nexport interface TestCount {\n\tpass: number;\n\tfail: number;\n\tskip: number;\n\ttimeout: number;\n\ttotal: number;\n}\n\nexport type SerializedTestResult = SerializedTestSuiteResult | SerializedTestCaseResult;\n\nexport interface SerializedTestSuiteResult {\n\ttype: \"TestSuiteResult\";\n\tname: string[];\n\tmark: TestMarkValue;\n\tfilename?: string;\n\tsuite: SerializedTestResult[];\n}\n\nexport interface SerializedTestCaseResult {\n\ttype: \"TestCaseResult\";\n\tname: string[];\n\tmark: TestMarkValue;\n\tfilename?: string;\n\tstatus: TestStatusValue;\n\terrorMessage?: string;\n\terrorRender?: unknown;\n\ttimeout?: number;\n}\n\nexport type RenderErrorFn = (names: string[], error: unknown, mark: TestMarkValue, filename?: string) => unknown;\n\n/**\n * The result of a test run. Can be a single test case or a suite of nested test results.\n */\nexport abstract class TestResult {\n\n\t/**\n\t * Create a TestResult for a suite of tests.\n\t * @param {string|string[]} name The name of the test. Can be a list of names.\n\t * @param {TestResult[]} tests The nested tests in this suite (can be test suites or individual test cases).\n\t * @param {string} [options.filename] The file that contained this suite (optional).\n\t * @param {TestMarkValue} [options.mark] Whether this suite was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestSuiteResult} The result.\n\t */\n\tstatic suite(\n\t\tname: string | string[],\n\t\ttests: TestResult[],\n\t\t{\n\t\t\tfilename,\n\t\t\tmark = TestMark.none\n\t\t}: {\n\t\t\tfilename?: string,\n\t\t\tmark?: TestMarkValue,\n\t\t} = {},\n\t): TestSuiteResult {\n\t\tensure.signature(arguments, [\n\t\t\t[ String, Array ],\n\t\t\tArray,\n\t\t\t[ undefined, {\n\t\t\t\tfilename: [ undefined, String ],\n\t\t\t\tmark: [ undefined, String ]\n\t\t\t}],\n\t\t]);\n\n\t\tif (!Array.isArray(name)) name = [ name ];\n\t\treturn new TestSuiteResult(name, tests, mark, filename);\n\t}\n\n\t/**\n\t * Create a TestResult for a test that passed.\n\t * @param {string|string[]} name The name of the test. Can be a list of names.\n\t * @param {string} [options.filename] The file that contained this test (optional).\n\t * @param {TestMarkValue} [options.mark] Whether this test was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic pass(\n\t\tname: string | string[],\n\t\t{\n\t\t\tfilename,\n\t\t\tmark,\n\t\t}: {\n\t\t\tfilename?: string,\n\t\t\tmark?: TestMarkValue,\n\t\t} = {}\n\t): TestCaseResult {\n\t\tensure.signature(arguments, [\n\t\t\t[ String, Array ],\n\t\t\t[ undefined, {\n\t\t\t\tfilename: [ undefined, String ],\n\t\t\t\tmark: [ undefined, String ]\n\t\t\t}],\n\t\t]);\n\n\t\tif (!Array.isArray(name)) name = [ name ];\n\t\treturn new TestCaseResult({ name, status: TestStatus.pass, filename, mark });\n\t}\n\n\t/**\n\t * Create a TestResult for a test that failed.\n\t * @param {string|string[]} name The name of the test. Can be a list of names.\n\t * @param {unknown} error The error that occurred.\n\t * @param {string} [filename] The file that contained this test (optional).\n\t * @param {TestMarkValue} [mark] Whether this test was marked with `.skip`, `.only`, or nothing.\n\t * @param {(name: string, error: unknown, mark: TestMarkValue, filename?: string) => unknown} [renderError] This\n\t *   function will be called and the results put into {@link errorRender}.\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic fail(\n\t\tname: string | string[],\n\t\terror: unknown,\n\t\t{\n\t\t\trenderError = renderErrorFn,\n\t\t\tfilename,\n\t\t\tmark,\n\t\t}: {\n\t\t\trenderError?: RenderErrorFn\n\t\t\tfilename?: string,\n\t\t\tmark?: TestMarkValue,\n\t\t} = {},\n\t): TestCaseResult {\n\t\tensure.signature(arguments, [\n\t\t\t[ String, Array ],\n\t\t\tensure.ANY_TYPE,\n\t\t\t[ undefined, {\n\t\t\t\trenderError: [ undefined, Function ],\n\t\t\t\tfilename: [ undefined, String ],\n\t\t\t\tmark: [ undefined, String ],\n\t\t\t}],\n\t\t]);\n\n\t\tif (!Array.isArray(name)) name = [ name ];\n\n\t\tlet errorMessage: string;\n\t\tif (error instanceof Error) errorMessage = error.message ?? \"\";\n\t\telse if (typeof error === \"string\") errorMessage = error;\n\t\telse errorMessage = util.inspect(error, { depth: Infinity });\n\n\t\tconst errorRender = renderError(name, error, mark ?? TestMark.none, filename);\n\n\t\treturn new TestCaseResult({ name, status: TestStatus.fail, errorMessage, errorRender, filename, mark });\n\t}\n\n\t/**\n\t * Create a TestResult for a test that was skipped.\n\t * @param {string|string[]} name The name of the test. Can be a list of names.\n\t * @param {string} [filename] The file that contained this test (optional).\n\t * @param {TestMarkValue} [mark] Whether this test was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic skip(\n\t\tname: string | string[],\n\t\t{\n\t\t\tfilename,\n\t\t\tmark,\n\t\t}: {\n\t\t\tfilename?: string,\n\t\t\tmark?: TestMarkValue,\n\t\t} = {}\n\t): TestCaseResult {\n\t\tensure.signature(arguments, [\n\t\t\t[ String, Array ],\n\t\t\t[ undefined, {\n\t\t\t\tfilename: [ undefined, String ],\n\t\t\t\tmark: [ undefined, String ]\n\t\t\t}],\n\t\t]);\n\n\t\tif (!Array.isArray(name)) name = [ name ];\n\t\treturn new TestCaseResult({ name, status: TestStatus.skip, filename, mark });\n\t}\n\n\t/**\n\t * Create a TestResult for a test that timed out.\n\t * @param {string|string[]} name The name of the test. Can be a list of names.\n\t * @param {number} timeout The length of the timeout.\n\t * @param {string} [filename] The file that contained this test (optional).\n\t * @param {TestMarkValue} [mark] Whether this test was marked with `.skip`, `.only`, or nothing.\n\t * @returns {TestCaseResult} The result.\n\t */\n\tstatic timeout(\n\t\tname: string | string[],\n\t\ttimeout: number,\n\t\t{\n\t\t\tfilename,\n\t\t\tmark,\n\t\t}: {\n\t\t\tfilename?: string,\n\t\t\tmark?: TestMarkValue,\n\t\t} = {},\n\t): TestCaseResult {\n\t\tensure.signature(arguments, [\n\t\t\t[ String, Array ],\n\t\t\tNumber,\n\t\t\t[ undefined, {\n\t\t\t\tfilename: [ undefined, String ],\n\t\t\t\tmark: [ undefined, String ]\n\t\t\t}],\n\t\t]);\n\t\t\n\t\tif (!Array.isArray(name)) name = [ name ];\n\t\treturn new TestCaseResult({ name, status: TestStatus.timeout, timeout, filename, mark });\n\t}\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {objects} serializedTestResult The serialized test result.\n\t * @returns {TestSuiteResult | TestCaseResult} The result object.\n\t * @see TestSuiteResult#serialize\n\t * @see TestCaseResult#serialize\n\t */\n\tstatic deserialize(serializedTestResult: SerializedTestResult): TestResult {\n\t\tensure.signatureMinimum(arguments, [{ type: String }]);\n\n\t\tconst type = serializedTestResult.type;\n\t\tswitch (type) {\n\t\t\tcase \"TestSuiteResult\": return TestSuiteResult.deserialize(serializedTestResult);\n\t\t\tcase \"TestCaseResult\": return TestCaseResult.deserialize(serializedTestResult);\n\t\t\tdefault: ensure.unreachable(`Unrecognized type '${type}' in serialized test result: ${serializedTestResult}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string | undefined} The file that contained the test (or suite), if any.\n\t */\n\tabstract get filename(): string | undefined;\n\n\t/**\n\t * @returns {string []} The name of the test (or suite), and all enclosing suites, with the outermost suite first.\n\t *   Does not include the file name.\n\t */\n\tabstract get name(): string[];\n\n\t/**\n\t * @return { TestMark } Whether the test (or suite) was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tabstract get mark(): TestMarkValue;\n\n\t/**\n\t * @returns {TestCaseResult[]} All the test results, excluding test suites, flattened into a single list.\n\t */\n\tabstract allTests(): TestCaseResult[];\n\n\t/**\n\t * @returns {TestCaseResult[]} All test results, with a mark (.only, etc.) that matches the requested marks,\n\t *   flattened into a single list, including test suites. However, if you access the properties of the test suites,\n\t *   such as {@link TestSuiteResult.tests}, those properties wonâ€™t be filtered.\n\t */\n\tabstract allMatchingMarks(...marks: TestMarkValue[]): TestResult[];\n\n\t/**\n\t * Convert this result into a bare object later deserialization.\n\t * @returns {SerializedTestSuiteResult} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tabstract serialize(): SerializedTestResult;\n\n\t/**\n\t * Determine if this test result is identical to another test result. To be identical, they must have the same\n\t * results, in the same order, with the same names, filenames, and marks (.only etc.).\n\t * @param {any} that The thing to compare against\n\t * @returns {boolean}\n\t */\n\tabstract equals(that: TestResult): boolean;\n}\n\n/**\n * The result of running a test suite.\n */\nexport class TestSuiteResult extends TestResult {\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {SerializedTestSuiteResult} serializedTestResult The serialized test result.\n\t * @returns {TestSuiteResult} The result object.\n\t * @see TestResult#deserialize\n\t */\n\tstatic deserialize({ name, filename, suite, mark }: SerializedTestSuiteResult): TestSuiteResult {\n\t\tensure.signature(arguments, [{\n\t\t\ttype: String,\n\t\t\tname: Array,\n\t\t\tmark: String,\n\t\t\tfilename: [ undefined, String ],\n\t\t\tsuite: Array,\n\t\t}], [ \"serialized TestSuiteResult\" ]);\n\n\t\tconst deserializedSuite = suite.map(test => TestResult.deserialize(test));\n\t\treturn new TestSuiteResult(name, deserializedSuite, mark, filename);\n\t}\n\n\tprivate readonly _name: string[];\n\tprivate readonly _tests: TestResult[];\n\tprivate readonly _mark: TestMarkValue;\n\tprivate readonly _filename?: string;\n\n\t/** Internal use only. (Use {@link TestResult.suite} instead.) */\n\tconstructor(name: string[], tests: TestResult[], mark: TestMarkValue, filename?: string) {\n\t\tsuper();\n\t\tthis._name = name;\n\t\tthis._tests = tests;\n\t\tthis._mark = mark;\n\t\tthis._filename = filename;\n\t}\n\n\tget name(): string[] {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * @returns {string | undefined} The file that contained the suite, if any.\n\t */\n\tget filename(): string | undefined {\n\t\treturn this._filename;\n\t}\n\n\t/**\n\t * @return { TestMarkValue } Whether the test was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tget mark(): TestMarkValue {\n\t\treturn this._mark;\n\t}\n\n\t/**\n\t * @returns { TestResult[] } The tests in this suite, which can either be test case results or test suite results.\n\t */\n\tget tests(): TestResult[] {\n\t\treturn this._tests;\n\t}\n\n\t/**\n\t * Convert this suite to a nicely-formatted string. The string describes the tests that have marks (such as .only)\n\t * and provides details about the tests that have failed or timed out. It doesn't provide any details about the tests\n\t * that have passed or been skipped, except for the ones that have marks. After the details, it displays a summary of\n\t * the number of tests that have passed, failed, etc., and the average time required per test.\n\t *\n\t * This is a convenience method. For more control over rendering, use {@link TestRenderer} instead.\n\t *\n\t * @param {string} [preamble=\"\"] A string to write before the test results, but only if there are any marks or errors.\n\t * @param {number} elapsedMs The total time required to run the test suite, in milliseconds.\n\t *   If there are no marks or errors, the preamble is ignored. Defaults to an empty string.\n\t * @returns The formatted string.\n\t */\n\trender(preamble: string = \"\", elapsedMs?: number): string {\n\t\tensure.signature(arguments, [ [ undefined, String ], [ undefined, Number ]]);\n\n\t\tconst renderer = TestRenderer.create();\n\t\tconst marks = this.allMarkedResults();\n\t\tconst errors = this.allMatchingTests(TestStatus.fail, TestStatus.timeout);\n\n\t\tconst markRender = renderer.renderMarksAsLines(marks);\n\t\tconst errorRender = renderer.renderAsMultipleLines(errors);\n\t\tconst summaryRender = renderer.renderSummary(this, elapsedMs);\n\n\t\tif (marks.length > 0 && errors.length > 0) {\n\t\t\treturn preamble + markRender + \"\\n\\n\\n\" + errorRender + \"\\n\\n\" + summaryRender;\n\t\t}\n\t\telse if (marks.length > 0) {\n\t\t\treturn preamble + markRender + \"\\n\\n\" + summaryRender;\n\t\t}\n\t\telse if (errors.length > 0) {\n\t\t\treturn preamble + errorRender + \"\\n\\n\" + summaryRender;\n\t\t}\n\t\telse {\n\t\t\treturn summaryRender;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} All the test results, excluding test suites, flattened into a single list.\n\t */\n\tallTests(): TestCaseResult[] {\n\t\tensure.signature(arguments, []);\n\n\t\tconst tests: TestCaseResult[] = [];\n\t\tthis._tests.forEach((result: TestResult) => {\n\t\t\tresult.allTests().forEach(subTest => tests.push(subTest));\n\t\t});\n\t\treturn tests;\n\t}\n\n\t/**\n\t * Finds all the test results that match the provided statuses.\n\t * @param {TestStatus[]} statuses The statuses to match.\n\t * @returns {TestCaseResult[]} The test results.\n\t */\n\tallMatchingTests(...statuses: TestStatusValue[]): TestCaseResult[] {\n\t\treturn this.allTests().filter(test => statuses.includes(test.status));\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} All test results, with a mark (.only, etc.) that matches the requested marks,\n\t *   flattened into a single list, including test suites. However, if you access the properties of the test suites,\n\t *   such as {@link TestSuiteResult.tests}, those properties wonâ€™t be filtered.\n\t */\n\tallMarkedResults(): TestResult[] {\n\t\tensure.signature(arguments, []);\n\n\t\tconst allMarks = new Set(Object.values(TestMark));\n\t\tallMarks.delete(TestMark.none);\n\t\treturn this.allMatchingMarks.apply(this, [ ...allMarks ]);\n\t}\n\n\tallMatchingMarks(...marks: TestMarkValue[]): TestResult[] {\n\t\tensureValidMarks(marks);\n\n\t\tconst results = new Set<TestResult>();\n\t\tif (marks.includes(this.mark)) results.add(this);\n\t\tthis._tests.forEach((result: TestResult) => {\n\t\t\tif (marks.includes(result.mark)) results.add(result);\n\t\t\tresult.allMatchingMarks.apply(result, marks).forEach(subResult => results.add(subResult));\n\t\t});\n\t\treturn [ ...results ];\n\t}\n\n\t/**\n\t * @returns {string[]} All the test files with 100% passing tests--nothing that was skipped, failed, or timed out.\n\t */\n\tallPassingFiles(): string[] {\n\t\tensure.signature(arguments, []);\n\n\t\tconst allFiles = new Set<string>();\n\t\tconst notPassFiles = new Set<string>();\n\t\tthis.allTests()\n\t\t\t.filter(test => test.filename !== undefined)\n\t\t\t.forEach(test => {\n\t\t\t\tallFiles.add(test.filename!);\n\t\t\t\tif (!test.isPass()) notPassFiles.add(test.filename!);\n\t\t\t});\n\n\t\treturn [ ...differencePolyfill(allFiles, notPassFiles) ];\n\n\t\tfunction differencePolyfill<T>(leftSet: Set<T>, rightSet: Set<T>): Set<T> {\n\t\t\t// Included in Node v22.0; remove this polyfill and replace with left.difference(right) when that enters LTS\n\t\t\treturn new Set([ ...leftSet ].filter(value => !rightSet.has(value)));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {TestCount} A summary count of this suite's results. Includes a count of each type of test result and the\n\t *   total number of tests.\n\t */\n\tcount(): TestCount {\n\t\tconst count = {\n\t\t\t[TestStatus.pass]: 0,\n\t\t\t[TestStatus.fail]: 0,\n\t\t\t[TestStatus.skip]: 0,\n\t\t\t[TestStatus.timeout]: 0,\n\t\t\ttotal: 0,\n\t\t};\n\n\t\tthis.allTests().forEach(test => {\n\t\t\tcount[test.status]++;\n\t\t\tcount.total++;\n\t\t});\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * Convert this suite into a bare object later deserialization.\n\t * @returns {SerializedTestSuiteResult} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tserialize(): SerializedTestSuiteResult {\n\t\treturn {\n\t\t\ttype: \"TestSuiteResult\",\n\t\t\tname: this._name,\n\t\t\tmark: this._mark,\n\t\t\tfilename: this._filename,\n\t\t\tsuite: this._tests.map(test => test.serialize()),\n\t\t};\n\t}\n\n\tequals(that: TestResult): boolean {\n\t\tif (!(that instanceof TestSuiteResult)) return false;\n\t\tif (this._mark !== that._mark) return false;\n\n\t\tif (this._tests.length !== that._tests.length) return false;\n\t\tfor (let i = 0; i < this._tests.length; i++) {\n\t\t\tconst thisResult = this._tests[i]!;\n\t\t\tconst thatResult = that._tests[i]!;\n\t\t\tif (!thisResult.equals(thatResult)) return false;\n\t\t}\n\n\t\tconst sameName = util.isDeepStrictEqual(this._name, that._name);\n\t\treturn sameName && this._filename === that._filename;\n\t}\n\n}\n\n\n/**\n * The result of running an individual test.\n */\nexport class TestCaseResult extends TestResult {\n\n\t/**\n\t * For use by {@link TestRunner}. Converts a serialized test result back into a TestResult instance.\n\t * @param {object} serializedTestResult The serialized test result.\n\t * @returns {TestCaseResult} The result object.\n\t * @see TestResult#deserialize\n\t */\n\tstatic deserialize(serializedResult: SerializedTestCaseResult): TestCaseResult {\n\t\tensure.signature(arguments, [{\n\t\t\ttype: String,\n\t\t\tname: Array,\n\t\t\tmark: String,\n\t\t\tfilename: [ undefined, String ],\n\t\t\tstatus: String,\n\t\t\terrorMessage: [ undefined, String ],\n\t\t\terrorRender: ensure.ANY_TYPE,\n\t\t\ttimeout: [ undefined, Number ],\n\t\t}], [ \"serialized TestCaseResult\" ]);\n\n\t\treturn new TestCaseResult(serializedResult);\n\t}\n\n\tprivate _name: string[];\n\tprivate _filename?: string;\n\tprivate _status: TestStatusValue;\n\tprivate _mark: TestMarkValue;\n\tprivate _errorMessage?: string;\n\tprivate _errorRender?: unknown;\n\tprivate _timeout?: number;\n\n\t/** Internal use only. (Use {@link TestResult} factory methods instead.) */\n\tconstructor(\n\t\t{\n\t\t\tname,\n\t\t\tstatus,\n\t\t\terrorMessage,\n\t\t\terrorRender,\n\t\t\ttimeout,\n\t\t\tfilename,\n\t\t\tmark,\n\t\t}: {\n\t\t\tname: string[],\n\t\t\tstatus: TestStatusValue,\n\t\t\terrorMessage?: string,\n\t\t\terrorRender?: unknown,\n\t\t\ttimeout?: number,\n\t\t\tfilename?: string,\n\t\t\tmark?: TestMarkValue\n\t\t},\n\t) {\n\t\tsuper();\n\t\tthis._name = name;\n\t\tthis._filename = filename;\n\t\tthis._status = status;\n\t\tthis._mark = mark ?? TestMark.none;\n\t\tthis._errorMessage = errorMessage;\n\t\tthis._errorRender = errorRender;\n\t\tthis._timeout = timeout;\n\t}\n\n\tget filename(): string | undefined {\n\t\treturn this._filename;\n\t}\n\n\tget name(): string[] {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * @returns {TestStatusValue} Whether this test passed, failed, etc.\n\t */\n\tget status(): TestStatusValue {\n\t\treturn this._status;\n\t}\n\n\t/**\n\t * @return { TestMark } Whether the test was explicitly marked with `.skip`, `.only`, or not at all.\n\t */\n\tget mark(): TestMarkValue {\n\t\treturn this._mark;\n\t}\n\n\t/**\n\t * @returns {string} A short description of the reason this test failed. If the error is an Error instance, it's\n\t *   equal to the error's `message` property. Otherwise, the error is converted to a string using `util.inspect()`.\n\t * @throws {Error} Throws an error if this test didn't fail.\n\t */\n\tget errorMessage(): string {\n\t\tensure.that(this.isFail(), \"Attempted to retrieve error message from a test that didn't fail\");\n\t\treturn this._errorMessage!;\n\t}\n\n\t/**\n\t * @returns {unknown} The complete rendering of the reason this test failed. May be of any type, depending on how\n\t *   `renderError()` in TestOptions is defined, but it defaults to a string.\n\t * @throws {Error} Throws an error if this test didn't fail.\n\t */\n\tget errorRender(): unknown {\n\t\tensure.that(this.isFail(), \"Attempted to retrieve error render from a test that didn't fail\");\n\t\treturn this._errorRender!;\n\t}\n\n\t/**\n\t * @returns {number} The timeout that this test didn't satisfy. Note that this is not the actual amount of run time\n\t *   of the test.\n\t * @throws {Error} Throws an error if this test didn't time out.\n\t */\n\tget timeout(): number {\n\t\tensure.that(this.isTimeout(), \"Attempted to retrieve timeout from a test that didn't time out\");\n\t\treturn this._timeout!;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test passed.\n\t */\n\tisPass(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this.status === TestStatus.pass;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test failed.\n\t */\n\tisFail(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this.status === TestStatus.fail;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test was skipped.\n\t */\n\tisSkip(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this.status === TestStatus.skip;\n\t}\n\n\t/**\n\t * @returns {boolean} True if this test timed out.\n\t */\n\tisTimeout(): boolean {\n\t\tensure.signature(arguments, []);\n\t\treturn this.status === TestStatus.timeout;\n\t}\n\n\t/**\n\t * Render the test case as a single color-coded character.\n\t *\n\t * This is a convenience method that calls {@link TestRenderer.renderAsCharacters()}. For more control over rendering,\n\t * use that class instead.\n\t *\n\t * @returns The formatted character.\n\t */\n\trenderAsCharacter(): string {\n\t\tensure.signature(arguments, []);\n\n\t\treturn TestRenderer.create().renderAsCharacters(this);\n\t}\n\n\t/**\n\t * Render the test case as a single line containing its status (pass, fail, etc.) and names.\n\t *\n\t * This is a convenience method that calls {@link TestRenderer.renderAsSingleLines()}. For more control over\n\t * rendering, use that class instead.\n\t *\n\t * @returns The formatted line.\n\t */\n\trenderAsSingleLine(): string {\n\t\tensure.signature(arguments, []);\n\n\t\treturn TestRenderer.create().renderAsSingleLines(this);\n\t}\n\n\t/**\n\t * Render the test case as a multiple lines containing all of its details.\n\t *\n\t * This is a convenience method that calls {@link TestRenderer.renderAsMultipleLines()}. For more control over\n\t * rendering, use that class instead.\n\t *\n\t * @returns The formatted lines.\n\t */\n\trenderAsMultipleLines(): string {\n\t\tensure.signature(arguments, []);\n\n\t\treturn TestRenderer.create().renderAsMultipleLines(this);\n\t}\n\n\t/**\n\t * @returns {TestCaseResult[]} This test converted into a list of one.\n\t */\n\tallTests(): TestCaseResult[] {\n\t\tensure.signature(arguments, []);\n\t\treturn [ this ];\n\t}\n\n\tallMatchingMarks(...marks: TestMarkValue[]): TestResult[] {\n\t\tensureValidMarks(marks);\n\n\t\tif (marks.includes(this._mark)) return [ this ];\n\t\telse return [];\n\t}\n\n\t/**\n\t * Convert this result into a bare object later deserialization.\n\t * @returns {object} The serialized object.\n\t * @see TestResult.deserialize\n\t */\n\tserialize(): SerializedTestCaseResult {\n\t\tensure.signature(arguments, []);\n\n\t\treturn {\n\t\t\ttype: \"TestCaseResult\",\n\t\t\tname: this._name,\n\t\t\tmark: this._mark,\n\t\t\tfilename: this._filename,\n\t\t\tstatus: this._status,\n\t\t\terrorMessage: this._errorMessage,\n\t\t\terrorRender: this._errorRender,\n\t\t\ttimeout: this._timeout,\n\t\t};\n\t}\n\n\tequals(that: TestResult): boolean {\n\t\tif (!(that instanceof TestCaseResult)) return false;\n\n\t\tconst sameName = util.isDeepStrictEqual(this._name, that._name);\n\t\tconst sameError = this._errorMessage === that._errorMessage;\n\n\t\treturn sameName &&\n\t\t\tsameError &&\n\t\t\tthis._status === that._status &&\n\t\t\tthis._mark === that._mark &&\n\t\t\tthis._timeout === that._timeout &&\n\t\t\tthis.filename === that.filename;\n\t}\n\n}\n\nfunction ensureValidMarks(marks: TestMarkValue[]) {\n\tconst validMarks = Object.values(TestMark);\n\tmarks.forEach((mark, i) => {\n\t\tensure.that(validMarks.includes(mark), `Argument #${i} was '${mark}', which isn't a valid mark`);\n\t});\n}"],"names":["ensure","util","renderError","renderErrorFn","TestRenderer","TestStatus","pass","fail","skip","timeout","TestMark","none","only","TestResult","suite","name","tests","filename","mark","signature","arguments","String","Array","undefined","isArray","TestSuiteResult","TestCaseResult","status","error","ANY_TYPE","Function","errorMessage","Error","message","inspect","depth","Infinity","errorRender","Number","deserialize","serializedTestResult","signatureMinimum","type","unreachable","deserializedSuite","map","test","_name","_tests","_mark","_filename","constructor","render","preamble","elapsedMs","renderer","create","marks","allMarkedResults","errors","allMatchingTests","markRender","renderMarksAsLines","renderAsMultipleLines","summaryRender","renderSummary","length","allTests","forEach","result","subTest","push","statuses","filter","includes","allMarks","Set","Object","values","delete","allMatchingMarks","apply","ensureValidMarks","results","add","subResult","allPassingFiles","allFiles","notPassFiles","isPass","differencePolyfill","leftSet","rightSet","value","has","count","total","serialize","equals","that","i","thisResult","thatResult","sameName","isDeepStrictEqual","serializedResult","_status","_errorMessage","_errorRender","_timeout","isFail","isTimeout","isSkip","renderAsCharacter","renderAsCharacters","renderAsSingleLine","renderAsSingleLines","sameError","validMarks"],"mappings":"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"}